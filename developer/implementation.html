<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://willpett.github.io/revbayes_tutorials/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/revbayes_tutorials/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/revbayes_tutorials/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/revbayes_tutorials/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/revbayes_tutorials/assets/css/main.css" />
    <title>RevBayes: Implementing functions, distributions, and moves</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a href="https://revbayes.github.io" class="pull-left">
        <img class="navbar-logo" src="/revbayes_tutorials/assets/img/aquabayes-desaturated.png" alt="RevBayes Logo" />
      </a>
      
      
      <a class="navbar-brand" href="/revbayes_tutorials/">Home</a>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">

	
        <li><a href="/revbayes_tutorials/software/">Software</a></li>
        <li><a href="/revbayes_tutorials/developer/">Developer</a></li>
        <li><a href="/revbayes_tutorials/tutorials/">Tutorials</a></li>
        <li><a href="/revbayes_tutorials/workshops/">Workshops</a></li>
      </ul>
      <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form>
    </div>
  </div>
</nav>

      <div class="row">
	<h1 class="maintitle">Implementing functions, distributions, and moves</h1>
	<h3 class="subtitle">Getting started with RevBayes development</h3>
	<h4 class="maintitle">Jeremy M. Brown, Rosana Zenil-Ferguson, Jordan Koch, Will Pett</h4>
</div>

      
<blockquote class="overview no-print" id="overview">
  <h2>Overview</h2>
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul>
          <li>None</li>
          </ul>
        
    </div>
  </div>
</blockquote>

<blockquote class="tutorial_files no-print" id="tutorial_files">
  <h2>Data files and scripts</h2>
  
    <div class="row" id="script_row">
      <div class="col-md-9">
          <strong>Scripts</strong>
          <ul id="scripts"></ul>
        </div>
    </div>
</blockquote>
      
<h1 class="section" id="implementing-a-metropolis-hastings-move">Implementing a Metropolis-Hastings Move</h1>

<h2 class="subsection" id="general-info-before-getting-started">General info before getting started</h2>

<p>The steps to implementing a new move vary slightly, depending on the move’s type (e.g., Metropolis-Hastings versus Gibbs). For the purposes of this guide, we will focus on a Metropolis-Hastings move.</p>

<p>In general, the fastest and easiest way to get help is to find the most similar move already implemented in RevBayes and use it as a guide. Remember that, as with implementing a new distribution or function, you’ll need to add relevant code to both the core of RevBayes and the language. Also remember that you’ll need to work out the math appropriate for your move (e.g., the Hastings ratio) ahead of time.</p>

<h2 class="subsection" id="steps">Steps</h2>

<ol>
  <li>
    <p><em>Orienting within the repository</em> - For the <strong>core</strong>, navigate in the repository to <code class="highlighter-rouge">src/core/moves</code>. For a Metropolis-Hastings move, we’ll then go into the <code class="highlighter-rouge">proposal</code> directory. In this directory, you can find several templates for generic proposal classes, as well as subdirectories containing moves for specific parameter types. To keep things easy, we’ll focus on a single scalar parameter, so we’ll navigate one step further into the <code class="highlighter-rouge">scalar</code> directory. For the <strong>language</strong>, navigate to <code class="highlighter-rouge">src/revlanguage/moves</code>. For this example, as we did in the core, we’ll focus on a move for a scalar parameter, so we’ll then open <code class="highlighter-rouge">scalar</code>. To <strong>register</strong> our new move after it’s implemented, we’ll also need to update the file <code class="highlighter-rouge">src/revlanguage/workspace/RbRegister_Move.cpp</code>.</p>
  </li>
  <li>
    <p><em>Creating new files for the core</em> - As an example, we’ll implement a new move that draws a random value from a Gamma distribution and proposes a new scalar by multiplying the current value by the draw from the Gamma. This move will be called a “Gamma Scaling move”. Since this move is similar to an existing scaling move, we can start by copying the file <code class="highlighter-rouge">ScaleProposal.h</code> and naming the new copy <code class="highlighter-rouge">GammaScaleProposal.h</code>. As a reminder, we’re working in the directory <code class="highlighter-rouge">src/core/moves/proposal/scalar/</code>.</p>

    <p>Once the new <strong>header file</strong> is created and named, we can update the content to match our new move. The simplest changes involve renaming things to match the new move (e.g., updating the preprocessor macro from <code class="highlighter-rouge">ScaleProposal_H</code> to <code class="highlighter-rouge">GammaScaleProposal_H</code>, or changing the name of object references and constructor from <code class="highlighter-rouge">ScaleProposal</code> to <code class="highlighter-rouge">GammaScaleProposal</code>). The comments at the top of the header file that describe how the move works should also be updated, but these changes will obviously be specific to the move being implemented.</p>

    <p>Next, we’ll need to create a <strong>new .cpp file</strong> containing the implementation of our new move. As with the header, it’s easiest to copy and rename an existing file, so we’ll use <code class="highlighter-rouge">ScaleProposal.cpp</code> as our template, copy it, and rename to <code class="highlighter-rouge">GammaScaleProposal.cpp</code>. As with the header file, most of the necessary changes involve updating the names of variables and function names. If the move requires access to other math functions, additional header files may need to be included at the top. Explore <code class="highlighter-rouge">src/core/math</code> as needed to find the necessary functions or distributions. For our example, the number and type of variables used by our move is the same as our template, so we don’t need to modify the constructor or variable initialization, other than updating the constructor name. Similarly for this example, we don’t need to alter the code in the <code class="highlighter-rouge">::cleanProposal</code>, <code class="highlighter-rouge">::clone</code>, <code class="highlighter-rouge">::prepareProposal</code>, <code class="highlighter-rouge">::printParameterSummary</code>, <code class="highlighter-rouge">::undoProposal</code>, <code class="highlighter-rouge">::swapNodeInternal</code>, and <code class="highlighter-rouge">::tune</code> methods as these are common to our template and new moves (and will be identical to many of the scalar moves), but we do need to update the class names associated with the methods (i.e., <code class="highlighter-rouge">ScaleMove::</code> -&gt; <code class="highlighter-rouge">GammaScaleMove::</code>). For the <code class="highlighter-rouge">::getProposalName</code> method, we need to update the string in the method that provides a descriptive name for the move - <code class="highlighter-rouge">name = "Gamma Scaling"</code>. The bulk of the necessary changes for the new move will come in the <code class="highlighter-rouge">::propose</code> method and the help description above the method. For this example, the new <code class="highlighter-rouge">::propose</code> method looks like this:</p>
  </li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Perform the proposal.
 *
 * A gamma scaling proposal draws a random number from a gamma distribution u ~ Gamma(lambda*1,1)
 * and scales the current vale by u
 * where lambda is the tuning parameter of the Proposal to influence the size of the proposals.
 *
  * \return The hastings ratio.
 */</span>
<span class="kt">double</span> <span class="n">GammaScaleProposal</span><span class="o">::</span><span class="n">propose</span><span class="p">(</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">val</span> <span class="p">)</span>
<span class="p">{</span>
    
    <span class="c1">// Get random number generator
</span>    <span class="n">RandomNumberGenerator</span><span class="o">*</span> <span class="n">rng</span>     <span class="o">=</span> <span class="n">GLOBAL_RNG</span><span class="p">;</span>
    
    <span class="c1">// copy value
</span>    <span class="n">storedValue</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    
    <span class="c1">// Generate new value (no reflection, so we simply abort later if we propose value here outside of support)
</span>    <span class="kt">double</span> <span class="n">u</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">rv</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">*</span><span class="n">rng</span><span class="p">);</span>
    <span class="n">val</span> <span class="o">*=</span> <span class="n">u</span><span class="p">;</span>
    
    <span class="c1">// compute the Hastings ratio
</span>    <span class="kt">double</span> <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// compute the Hastings ratio
</span>        <span class="kt">double</span> <span class="n">forward</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">lnPdf</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">backward</span> <span class="o">=</span> <span class="n">RbStatistics</span><span class="o">::</span><span class="n">Gamma</span><span class="o">::</span><span class="n">lnPdf</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">u</span><span class="p">));</span>
        
        <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="n">backward</span> <span class="o">-</span> <span class="n">forward</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>    <span class="c1">// The -log(u) term is the Jacobian
</span>    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">RbException</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ln_hastings_ratio</span> <span class="o">=</span> <span class="n">RbConstants</span><span class="o">::</span><span class="n">Double</span><span class="o">::</span><span class="n">neginf</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ln_hastings_ratio</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p><em>Creating new files for the rev language</em> -</p>
  </li>
  <li>
    <p><em>Testing the performance of the new move</em> - If properly implemented, a new move can be validated by running an MCMC analysis where the data are ignored and one tries to sample only the prior. This can be done in RevBayes by adding the <code class="highlighter-rouge">underPrior=TRUE</code> option as an argument to the <code class="highlighter-rouge">.run()</code> method of an <code class="highlighter-rouge">mcmc</code> object. The recommended strategy is to implement the simplest possible model that uses a variable of the type appropriate for the new move, and assigning that variable an easily validated prior (e.g., a uniform). Run the analysis with only the new move operating on that variable and then plot the variable’s marginal distribution to make sure it matches the prior.</p>
  </li>
</ol>

<h1 class="section" id="implementing-a-function">Implementing a function</h1>

<p>There are two main classes of functions in RevBayes: member functions and typed functions. Member functions are functions used inside of deterministic nodes and allow access to member methods of a member object. Typed functions are either values within directed acyclic graph (DAG) nodes (i.e. random variables of some distribution), or are associated with a deterministic node. All deterministic nodes hold a function, the value of these deterministic nodes are returned by a call to that function. This has the advantage of simply modifying the value instead of creating a new object.</p>

<p>For our example implementation we will be implementing a typed function. We will begin with a simple example of implementing a mathematical function, the hyperbolic cosine function. First we need to add two files to the RevBayes source code, a <code class="highlighter-rouge">HyperbolicCosineFunction.cpp</code> and a <code class="highlighter-rouge">HyperbolicCosineFunction.h</code>. These will go within <code class="highlighter-rouge">revbayes/src/core/functions/math</code> since we are adding a function and it is a mathematical function.</p>

<p>First, we will write our header file. Within our header file, we need to <code class="highlighter-rouge">include</code> a few other RevBayes header files, including <code class="highlighter-rouge">ContinousFunction.h</code> since hyperbolic cosine is a continuous function, and <code class="highlighter-rouge">TypedDagNode.h</code> since our typed function deals with nodes of DAGs.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef HyperbolicCosineFunction_h 
#define HyperbolicCosineFunction_h
</span>
<span class="cp">#include "ContinuousFunction.h"
#include "TypedDagNode.h"
#include &lt;cmath&gt;
</span>
<span class="k">namespace</span> <span class="n">RevBayesCore</span> <span class="p">{</span>
    <span class="cm">/**
     * \brief Hyperbolic Cosine of a real number.
     *
     * Compute the hyperbolic cosine of a real number x. (cosh(x) = (exp(x) + exp(-x))/2).
     *
     * \copyright (c) Copyright 2009-2018 (GPL version 3)
     * \author &lt;your-name&gt;
     * \since Version 1.0, 2015-01-31
     *
     */</span>
    <span class="k">class</span> <span class="nc">HyperbolicCosineFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ContinuousFunction</span> <span class="p">{</span>

        <span class="k">public</span><span class="o">:</span>
                                        <span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span> 

            <span class="n">HyperbolicCosineFunction</span><span class="o">*</span>     <span class="n">clone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">//!&lt; creates a clone
</span>            <span class="kt">void</span>                        <span class="n">update</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">//!&lt; recomputes the value
</span>
        <span class="k">protected</span><span class="o">:</span>
            <span class="kt">void</span>                        <span class="n">swapParameterInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">oldP</span><span class="p">,</span> <span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">newP</span><span class="p">);</span> <span class="c1">//!&lt; Implementation of swapping parameters
</span>
        <span class="k">private</span><span class="o">:</span>
            <span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span><span class="p">;</span>

    <span class="p">};</span>
<span class="p">}</span>


<span class="cp">#endif
</span></code></pre></div></div>
<p>The first part of this file should be the standard header that goes in all the files giving a brief description about what that file is as well as information about the copyright and the author of that file.
Next, after including the necessary header files, we have to ensure that our new function is included within the <code class="highlighter-rouge">RevBayesCore</code> namespace.
Here we are implementing our hyperbolic cosine function as its own class that is derived from the continuous function class that is derived from the typed function class. This class stores the hyperbolic cosine of a value that is held in a DAG node. We have also defined a clone method which can create a clone of our class, and an update method which will update the value of our Hyperbolic Cosine class whenever the value of the DAG node changes. Now we will move on to the <code class="highlighter-rouge">HyperbolicCosineFunction.cpp</code> file.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "HyperbolicCosineFunction.h"
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">RevBayesCore</span><span class="p">;</span>

<span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">ContinuousFunction</span><span class="p">(</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">),</span>
<span class="n">x</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">addParameter</span><span class="p">(</span> <span class="n">a</span> <span class="p">);</span>
<span class="p">}</span>


<span class="n">HyperbolicCosineFunction</span><span class="o">*</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">clone</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">HyperbolicCosineFunction</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">swapParameterInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">oldP</span><span class="p">,</span> <span class="k">const</span> <span class="n">DagNode</span> <span class="o">*</span><span class="n">newP</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">oldP</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">newP</span> <span class="p">);</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="kt">void</span> <span class="n">HyperbolicCosineFunction</span><span class="o">::</span><span class="n">update</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    
    <span class="c1">// recompute and set the internal value
</span>    <span class="kt">double</span> <span class="n">myValue</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">getValue</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">myValue</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">myValue</span><span class="p">);</span>
    <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">x1</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Now all we need to do is add the hyperbolic cosine function to the <code class="highlighter-rouge">revlanguage</code> side of things so that when we are using <code class="highlighter-rouge">Rev</code> we can use our function. First we need to add <code class="highlighter-rouge">Func_hyperbolicCosine.cpp</code> and <code class="highlighter-rouge">Func_hyperbolicCosine.h</code> to <code class="highlighter-rouge">/src/revlanguage/functions/math/</code>. Note that the directory structure of <code class="highlighter-rouge">revlanguage</code> is similar to that of the <code class="highlighter-rouge">core</code>. The Revlanguage side serves as a wrapper of the function that we just wrote in the <code class="highlighter-rouge">core</code>.</p>

<p>The <code class="highlighter-rouge">Func_hyperbolicCosine.h</code> should look like the following:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#ifndef Func_hyperbolicCosine_h
#define Func_hyperbolicCosine_h
</span>
<span class="cp">#include "Real.h"
#include "RlTypedFunction.h"
</span>
<span class="cp">#include &lt;string&gt;
</span>
<span class="k">namespace</span> <span class="n">RevLanguage</span> <span class="p">{</span>
    
    <span class="cm">/**
     * The RevLanguage wrapper of the hyperbolic Cosine function (sinh()).
     *
     * The RevLanguage wrapper of the hyperbolic function function connects
     * the variables/parameters of the function and creates the internal HyperbolicCosineFunction object.
     * Please read the HyperbolicCosineFunction.h for more info.
     *
     *
     * @copyright Copyright 2009-
     * @author The RevBayes Development Core Team (&lt;your-name&gt;)
     * @since 2016-09-26, version 1.0
     *
     */</span>
    <span class="k">class</span> <span class="nc">Func_hyperbolicCosine</span> <span class="o">:</span>  <span class="k">public</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span> <span class="p">{</span>
        
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Func_hyperbolicCosine</span><span class="p">(</span> <span class="kt">void</span> <span class="p">);</span>
        
        <span class="c1">// Basic utility functions
</span>        <span class="n">Func_hyperbolicCosine</span><span class="o">*</span>                         <span class="n">clone</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                          <span class="c1">//!&lt; Clone the object
</span>        <span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span>                       <span class="n">getClassType</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                                         <span class="c1">//!&lt; Get Rev type
</span>        <span class="k">static</span> <span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span>                          <span class="n">getClassTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>                                     <span class="c1">//!&lt; Get class type spec
</span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span>                                     <span class="n">getFunctionName</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                <span class="c1">//!&lt; Get the primary name of the function in Rev
</span>        <span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span>                                 <span class="n">getTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                    <span class="c1">//!&lt; Get the type spec of the instance
</span>        
        <span class="c1">// Function functions you have to override
</span>        <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span>            <span class="n">createFunction</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                                 <span class="c1">//!&lt; Create internal function object
</span>        <span class="k">const</span> <span class="n">ArgumentRules</span><span class="o">&amp;</span>                            <span class="n">getArgumentRules</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                               <span class="c1">//!&lt; Get argument rules
</span>        
    <span class="p">};</span>
    
<span class="p">}</span>


<span class="cp">#endif </span><span class="cm">/* Func_hyperbolicCosine_h */</span><span class="cp">
</span>
</code></pre></div></div>

<p>And the <code class="highlighter-rouge">Func_hyperbolicCosine.cpp</code> should look like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "Func_hyperbolicCosine.h"
#include "HyperbolicCosineFunction.h"
#include "Probability.h"
#include "Real.h"
#include "RlDeterministicNode.h"
#include "TypedDagNode.h"
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">RevLanguage</span><span class="p">;</span>

<span class="cm">/** default constructor */</span>
<span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">Func_hyperbolicCosine</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="o">:</span> <span class="n">TypedFunction</span><span class="o">&lt;</span><span class="n">Real</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    
<span class="p">}</span>


<span class="cm">/**
 * The clone function is a convenience function to create proper copies of inherited objected.
 * E.g. a.clone() will create a clone of the correct type even if 'a' is of derived type 'b'.
 *
 * \return A new copy of the process.
 */</span>
<span class="n">Func_hyperbolicCosine</span><span class="o">*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">clone</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="k">return</span> <span class="k">new</span> <span class="n">Func_hyperbolicCosine</span><span class="p">(</span> <span class="o">*</span><span class="k">this</span> <span class="p">);</span>
<span class="p">}</span>


<span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedFunction</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">createFunction</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">TypedDagNode</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Real</span><span class="o">&amp;&gt;</span><span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getVariable</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getRevObject</span><span class="p">()</span> <span class="p">).</span><span class="n">getDagNode</span><span class="p">();</span>
    <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RevBayesCore</span><span class="o">::</span><span class="n">HyperbolicCosineFunction</span><span class="p">(</span> <span class="n">x</span> <span class="p">);</span>
    
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Get argument rules */</span>
<span class="k">const</span> <span class="n">ArgumentRules</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getArgumentRules</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="k">static</span> <span class="n">ArgumentRules</span> <span class="n">argumentRules</span> <span class="o">=</span> <span class="n">ArgumentRules</span><span class="p">();</span>
    <span class="k">static</span> <span class="kt">bool</span>          <span class="n">rules_set</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">rules_set</span> <span class="p">)</span>
    <span class="p">{</span>
        
        <span class="n">argumentRules</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="k">new</span> <span class="n">ArgumentRule</span><span class="p">(</span> <span class="s">"x"</span><span class="p">,</span> <span class="n">Real</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">(),</span> <span class="s">"The value."</span><span class="p">,</span> <span class="n">ArgumentRule</span><span class="o">::</span><span class="n">BY_CONSTANT_REFERENCE</span><span class="p">,</span> <span class="n">ArgumentRule</span><span class="o">::</span><span class="n">ANY</span> <span class="p">)</span> <span class="p">);</span>
        
        <span class="n">rules_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">argumentRules</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getClassType</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rev_type</span> <span class="o">=</span> <span class="s">"Func_hyperbolicCosine"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">rev_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get class type spec describing type of object */</span>
<span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    
    <span class="k">static</span> <span class="n">TypeSpec</span> <span class="n">rev_type_spec</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="p">(</span> <span class="n">getClassType</span><span class="p">(),</span> <span class="k">new</span> <span class="n">TypeSpec</span><span class="p">(</span> <span class="n">Function</span><span class="o">::</span><span class="n">getClassTypeSpec</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
    
    <span class="k">return</span> <span class="n">rev_type_spec</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**
 * Get the primary Rev name for this function.
 */</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getFunctionName</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// create a name variable that is the same for all instance of this class
</span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">f_name</span> <span class="o">=</span> <span class="s">"cosh"</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">f_name</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">const</span> <span class="n">TypeSpec</span><span class="o">&amp;</span> <span class="n">Func_hyperbolicCosine</span><span class="o">::</span><span class="n">getTypeSpec</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    
    <span class="k">static</span> <span class="n">TypeSpec</span> <span class="n">type_spec</span> <span class="o">=</span> <span class="n">getClassTypeSpec</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">type_spec</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, we need to include the hyperbolic cosine function in the <code class="highlighter-rouge">RbRegister_Func.cpp</code> file located in the <code class="highlighter-rouge">/revlanguage/workspace/</code> directory. To do this go to the <code class="highlighter-rouge">RbRegister_Func.cpp</code> file and locate the math functions and type <code class="highlighter-rouge">#include Func_hyperbolicCosine.h</code> in the correct alphabetical order for that group. Now scroll down in that file until you find the math functions and add the line <code class="highlighter-rouge">addFunction( new Func_hyperbolicCosine());</code></p>

<h1 class="section" id="implementing-a-distribution">Implementing a distribution</h1>

<h2 class="subsection" id="general-info-before-getting-started">General info before getting started</h2>

<p>TESTING HELLO</p>

<ul>
  <li>
    <p>Within the RevBayes <strong>core</strong> directory, there are subdirectories for different categories of distributions. 
All predefined mathematical distributions that have been implemented exist in <code class="highlighter-rouge">core/distributions/math</code>.</p>
  </li>
  <li>
    <p>Note that when implementing a new distribution, you will need to create <code class="highlighter-rouge">.cpp</code> and <code class="highlighter-rouge">.h</code> files in both the <strong>revlanguage</strong> directory and the <strong>core</strong> directory. (For a refresher on the difference between these two directories, refer to the <a href="/revbayes_tutorials/developer/architecture.html">Getting familiar with the code</a> section of this Developer’s guide).
The overall naming format remains the same for every distribution in RevBayes. In the Beta Binomial Distribution example provided below, I specify what to name each file.</p>
  </li>
  <li>
    <p>It is often helpful to look at/borrow code from existing RevBayes distributions for general help on syntax and organization.</p>
  </li>
</ul>

<p>For the language side, one of the most important things is the create distribution function (it converts user-arguments into calculations). Also, the getParameterRules function is important (to get the degrees of freedom &amp; other things). It is often helpful to look at the code of existing distributions for general help on syntax &amp; organization.</p>

<ul>
  <li>
    <p>Within every new distribution, you will need to include some functions. For example, each new distribution must have: the get class type, name, and help functions. You may not need to implement these from scratch (if they’re dictated by the parent class &amp; are already present), but you will need to implement other functions within your distribution (e.g. cdf, rv, quantile).</p>
  </li>
  <li>
    <p>Distributions have a prefexed DN (dag node), and all moves have a previxed MV. RevBayes takes the name within &amp; creates the DN automatically, so be aware of this. For a refresher on DAG nodes, refer <a href="/revbayes_tutorials/developer/architecture.html">to this page</a>.</p>
  </li>
</ul>

<p>In the following steps, we’ll implement the <strong>Beta Binomial Distribution</strong> as an example, for syntax purposes.</p>

<h2 class="subsection" id="steps">Steps</h2>

<ol>
  <li>
    <p>Create new .cpp &amp; .h files in <code class="highlighter-rouge">revlanguage/distributions/math/</code>, named <code class="highlighter-rouge">Dist_betabinomial.cpp</code> and <code class="highlighter-rouge">Dist_betaBinomial.h</code>. 
 <strong>Note:</strong> all files in this directory will follow this naming format*</p>

    <p>To populate these files, look at existing examples of similar distributions for specific info on what to include &amp; on proper syntax.  For example, for the Beta Binomial distribution, I looked to the existing Binomial Distribution code for guidance.</p>
  </li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//add code here
</span></code></pre></div></div>

<ol>
  <li>Test
    <ol>
      <li>
        <p>Create new <code class="highlighter-rouge">.cpp</code> &amp; <code class="highlighter-rouge">.h</code> files in <code class="highlighter-rouge">core/distributions/math/</code>, named <code class="highlighter-rouge">BetaBinomialDistribution.cpp</code> and <code class="highlighter-rouge">BetaBinomialDistribution.h</code>.</p>

        <p><strong>Note:</strong> This is the object oriented wrapper code, that references the functions hard-coded in the next step.</p>
      </li>
      <li>
        <p>Create new .cpp and .h files in <code class="highlighter-rouge">core/math/Distributions/</code>, named <code class="highlighter-rouge">DistributionBetaBinomial.cpp</code> and <code class="highlighter-rouge">DistributionBetaBinomial.h</code>.</p>

        <p>These are the raw procedural functions in the RevBayes namespace (e.g. pdf, cdf, quantile); they are not derived functions. RbStatistics is a namespace. To populate these files, look at existing examples of similar distributions to get an idea of what functions to include, what variables are needed, and the proper syntax.</p>

        <p><strong>Note:</strong> This is the most time-consuming step in the entire process of implementing a new distribution.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>Navigate to <code class="highlighter-rouge">revlanguage/workspace/RbRegister_Dist.cpp</code></p>

    <p><strong>Every</strong> new implementation must be registered in RevBayes. All register files are located in the <code class="highlighter-rouge">revlanguage/workspace</code> directory, and there are different files for the different types of implementations (<code class="highlighter-rouge">RbRegister_Func.cpp</code> is for registering functions; <code class="highlighter-rouge">RbRegister_Move</code> is for registering moves; etc.).  We are implementing a distribution, so we will edit the <code class="highlighter-rouge">RbRegister_Dist.cpp file</code>.</p>
  </li>
  <li>
    <p>You need to have an include statement at the top of the RbRegister script, to effectively add your distribution to the RevBayes language. You also need to add code to the bottom of this file, and give it a type and a ‘new’ constructor. Generally, you can look within the file for an idea of proper syntax to use.</p>

    <p>For the Beta Binomial distribution, we navigate to the section in the file with the header ‘Distributions’ and then look for the sub-header dealing with ‘math distributions’. Then, add the following line of code:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "Dist_betaBinomial.h"
</span></code></pre></div>    </div>

    <p>This step registers the header file for the beta binomial distribution, effectively adding it to RevBayes.</p>

    <p>Next, navigate to the section of the file that initializes the global workspace. This section defines the workspace class, which houses info on all distributions. Then, add the following line of code:</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AddDistribution</span><span class="o">&lt;</span> <span class="n">Natural</span>		<span class="o">&gt;</span><span class="p">(</span> <span class="k">new</span> <span class="n">Dist_betaBinomial</span><span class="p">());</span>
</code></pre></div>    </div>

    <p>This adds the distribution to the workspace. Without this step, the betaBinomial will not be added to the revlanguage.</p>

    <p><strong>Note:</strong> Depending on the kind of distribution, you may need to change <code class="highlighter-rouge">Natural</code> to a different type (e.g. <code class="highlighter-rouge">Probability</code>, <code class="highlighter-rouge">Real</code>, <code class="highlighter-rouge">RealPos</code>, etc.).</p>

    <p>After registering your distribution, you are ready to test your code.</p>
  </li>
  <li>
    <p>Before pushing your changes, you should ensure your code is working properly.</p>

    <p>There are multiple ways to do this, so use your best judgment. As a best practice, you should first compile it to ensure there are no errors. Once it compiles with no problems, you can test in various ways (e.g. run each individual function within the new Beta Binomial distribution in R, then run the Binomial distribution with a Beta prior in Rev and see if the output matches).</p>

    <p>After ensuring your code runs properly, you are ready to add it to the git repo. We recommend reading through the <a href="/revbayes_tutorials/developer/git-flow.html">Git Workflow Best Practices</a> section of the Developer’s guide before pushing.</p>
  </li>
</ol>


      <ol class="bibliography"></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2>References</h2>"+elem_ol.outerHTML
	}
}
</script>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/revbayes_tutorials/license">License</a> | <a href="/revbayes_tutorials/citation">Cite RevBayes</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users' Forum</a>
    </div>
  </div>
  </div>
</footer>

    </div>
    <script src="/revbayes_tutorials/assets/js/vendor/jquery.min.js"></script>
<script src="/revbayes_tutorials/assets/js/vendor/FileSaver.min.js"></script>
<script src="/revbayes_tutorials/assets/js/vendor/jszip.min.js"></script>
<script src="/revbayes_tutorials/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(".highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge")
    this.classList = "Rev highlighter-rouge";
  
});
</script>

<script src="/revbayes_tutorials/assets/js/base.js"></script>

<script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

  </body>
</html>
