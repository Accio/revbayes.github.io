<h1 id="basic-commands">Basic Commands</h1>

<h2 id="introduction">Introduction</h2>

<p>This tutorial demonstrates the basic syntactical features of and and
shows how to set up and perform an analysis on “toy” statistical models
for linear regression. This tutorial focuses on explaining probabilistic
graphical models and the language <a href="#Hoehna2016b">(Höhna et al. 2016)</a>. A good reference for
probabilistic graphical models for Bayesian phylogenetic inference is
given in <a href="#Hoehna2014b">(Höhna et al. 2014)</a>. The statistical examples are borrowed from a
fourth year statistics course taught in the fall term 2011 at Stockholm
University.</p>

<p>The first section of this tutorial involves</p>

<ol>
  <li>
    <p>Creating different types of variables.</p>
  </li>
  <li>
    <p>Learning about functions.</p>
  </li>
</ol>

<p>Then we will see how to perform statistical inference using and by
implementing a Monte Carlo algorithm. Finally, we will see how ’s
built-in functions vastly simplify this inference task.</p>

<p>All of the files for this analysis are provided for you, and you can run
these without significant effort using the function in the console:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">source</span><span class="p">(</span><span class="s">"RevBayes_scripts/basics.Rev"</span><span class="p">)</span>
</code></pre></div></div>

<p>Nevertheless, you will learn more if you type in the commands directly.</p>

<p>Let’s start with the basic concepts for the interactive use of with (the
language of ). You should try to execute the statements step by step,
look at the output and try to understand what and why things are
happening. We start with some simple concepts to get familiar and used
to . By now you should have executed and you should see the command
prompt waiting for input. The best exercise is to write these statements
exactly in .</p>

<p>is an interpreted language for statistical computing and analyses in
evolutionary biology. Therefore, the basics are simple mathematical
operations, such as</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># Simple mathematical operators:
</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>                            <span class="err">#</span> <span class="n">Addition</span>
<span class="mi">10</span> <span class="o">-</span> <span class="mi">5</span>                           <span class="err">#</span> <span class="n">Subtraction</span>
<span class="mi">5</span> <span class="o">*</span> <span class="mi">5</span>                            <span class="err">#</span> <span class="n">Multiplication</span>
<span class="mi">10</span> <span class="o">/</span> <span class="mi">2</span>                           <span class="err">#</span> <span class="n">Division</span>
<span class="mi">2</span><span class="o">^</span><span class="mi">3</span>                              <span class="err">#</span> <span class="n">Exponentiation</span>
<span class="mi">5</span><span class="o">%</span><span class="mi">2</span>                              <span class="err">#</span> <span class="n">Modulo</span>
</code></pre></div></div>

<p>Just as a side note, you can also write multiple statements in the same
line if you separate these by a semicolon (). The statements will be
executed as if you wrote each on a single line.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>                    <span class="err">#</span> <span class="n">Multiple</span> <span class="n">statements</span> <span class="n">in</span> <span class="n">one</span> <span class="n">line</span>
</code></pre></div></div>

<p>Here you can see that comments always start with the hash symbol ().
Everything after the ‘’-symbol will be ignored. In addition to these
simple mathematical operations, we provide some standard math functions
which can be called by:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># Math-Functions
</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                           <span class="err">#</span> <span class="n">exponential</span> <span class="n">function</span>
<span class="n">ln</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                            <span class="err">#</span> <span class="n">logarithmic</span> <span class="n">function</span> <span class="n">with</span> <span class="n">natural</span> <span class="n">base</span>
<span class="n">sqrt</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>                         <span class="err">#</span> <span class="n">square</span> <span class="n">root</span> <span class="n">function</span> 
<span class="n">power</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>                       <span class="err">#</span> <span class="n">power</span> <span class="n">function</span><span class="o">:</span> <span class="n">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="o">^</span><span class="n">b</span>
</code></pre></div></div>

<p>Notice that is case-sensitive. That means, distinguishes upper and lower
case letter for both variable names and function names. For example,
only the first of these two calls will work</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                           <span class="err">#</span> <span class="n">correct</span> <span class="n">lower</span> <span class="k">case</span> <span class="n">name</span>
<span class="n">Exp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                           <span class="err">#</span> <span class="n">wrong</span> <span class="n">upper</span> <span class="k">case</span> <span class="n">name</span>
</code></pre></div></div>

<p>Moreover, we provide functions for the common statistical distributions.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># distribution functions
</span><span class="n">dexp</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">lambda</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>       <span class="err">#</span> <span class="n">exponential</span> <span class="n">distribution</span> <span class="n">density</span> <span class="n">function</span>
<span class="n">qexp</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>              <span class="err">#</span> <span class="n">exponential</span> <span class="n">distribution</span> <span class="n">quantile</span> <span class="n">function</span>
<span class="n">rexp</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>             <span class="err">#</span> <span class="n">random</span> <span class="n">draws</span> <span class="n">from</span> <span class="n">an</span> <span class="n">exponential</span> <span class="n">distribution</span>
<span class="n">dnorm</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>      <span class="err">#</span> <span class="n">normal</span> <span class="n">distribution</span> <span class="n">density</span> <span class="n">function</span>
<span class="n">rnorm</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>          <span class="err">#</span> <span class="n">random</span> <span class="n">draws</span> <span class="n">from</span> <span class="n">a</span> <span class="n">normal</span> <span class="n">distribution</span>
</code></pre></div></div>

<p>You may have noticed that we sometimes provided labels of the arguments
and sometimes not. You can always provide the argument labels and then
will match the arguments based on the labels.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dnorm</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">mean</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">sd</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>       <span class="err">#</span> <span class="n">normal</span> <span class="n">distribution</span> <span class="n">density</span> <span class="n">function</span>
</code></pre></div></div>

<p>If you do not provide the argument labels, then will match the arguments
by the best fitting types and the order in which you provided the
arguments.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dnorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>         <span class="err">#</span> <span class="n">correct</span> <span class="n">order</span>
<span class="n">dnorm</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>         <span class="err">#</span> <span class="n">mismatched</span> <span class="n">order</span>
</code></pre></div></div>

<p>You may provide also just some arguments with labels and leave the other
arguments without labels.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dnorm</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">sd</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>    <span class="err">#</span> <span class="n">partially</span> <span class="n">labeled</span>
</code></pre></div></div>

<p>If you do not remember what the parameter name or parameter names of a
function are, then you can simply type in the function name and will
tell you the possible parameters with their names.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dnorm</span>
</code></pre></div></div>

<h2 id="variable-declaration">Variable Declaration</h2>

<p>The next, and very important feature of , is variable declaration. We
have three types of (model) variables, namely constant, deterministic
and stochastic variables, which represent the same three types of DAG
nodes. Here we show how to construct the different variables and how
they behave differently. First, we focus on the difference between
constant and deterministic variables.</p>

<p>Let us begin by creating a constant variable with name and assigned the
value 1 to it. The left arrow assignment () always creates a constant
variable.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># Variable assignment: constant and deterministic
</span><span class="n">a</span> <span class="o">&lt;-</span> <span class="mi">1</span>                           <span class="err">#</span> <span class="n">assignment</span> <span class="n">of</span> <span class="n">constant</span> <span class="n">node</span> <span class="sc">'a'</span>
</code></pre></div></div>

<p>You see the value of ’a’ by just typing in the variable name and
pressing enter.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span>                                <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="sc">'a'</span>
</code></pre></div></div>

<p>If you want to see which type of variable (constant, deterministic or
stochastic) ’a’ has, then call the structure function for it.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                           <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">information</span> <span class="n">of</span> <span class="sc">'a'</span>
<span class="o">|*</span>   <span class="n">_variable</span>     <span class="o">=</span> <span class="n">a</span>
<span class="o">|*</span>   <span class="n">_RevType</span>      <span class="o">=</span> <span class="n">Natural</span>
<span class="o">|*</span>   <span class="n">_RevTypeSpec</span>  <span class="o">=</span> <span class="p">[</span> <span class="n">Natural</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">RevObject</span> <span class="p">]</span>
<span class="o">|*</span>   <span class="n">_value</span>        <span class="o">=</span> <span class="mi">1</span>
<span class="o">|*</span>   <span class="n">_dagType</span>      <span class="o">=</span> <span class="n">Constant</span> <span class="n">DAG</span> <span class="n">node</span>
<span class="o">|*</span>   <span class="n">_children</span>     <span class="o">=</span> <span class="p">[</span>  <span class="p">]</span>
<span class="o">|*</span>   <span class="p">.</span><span class="n">methods</span> <span class="o">=</span> <span class="kt">void</span> <span class="n">function</span> <span class="p">()</span>
</code></pre></div></div>

<p>An additional quite useful built-in function in is the function which
gives you only the type information of the variable and thus is a subset
of the function.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                          <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">type</span> <span class="n">information</span> <span class="n">of</span> <span class="sc">'a'</span>
<span class="o">|*</span>    <span class="n">Natural</span>
</code></pre></div></div>

<p>Next, we create a deterministic variable using the assignment computed
by and another deterministic variable computed by . Deterministic
variables are always created using the colon-equal assignment ().</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">:=</span> <span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                      <span class="err">#</span> <span class="n">assignment</span> <span class="n">of</span> <span class="n">deterministic</span> <span class="n">node</span> <span class="sc">'b'</span> <span class="n">with</span> <span class="n">the</span> <span class="n">exponential</span> <span class="n">function</span> <span class="n">with</span> <span class="n">parameter</span> <span class="sc">'a'</span>
<span class="n">b</span>                                <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="sc">'b'</span>
<span class="n">c</span> <span class="o">:=</span> <span class="n">ln</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>                       <span class="err">#</span> <span class="n">assignment</span> <span class="n">of</span> <span class="n">deterministic</span> <span class="n">node</span> <span class="sc">'c'</span> <span class="n">with</span> <span class="n">logarithmic</span> <span class="n">function</span> <span class="n">with</span> <span class="n">parameter</span> <span class="sc">'b'</span>
<span class="n">c</span>                                <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="sc">'c'</span>
</code></pre></div></div>

<p>Again, you see the type of the variable and additional information such
as which the parents and children are by calling the structure function
on it.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>                           <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">information</span> <span class="n">of</span> <span class="sc">'b'</span>
</code></pre></div></div>

<p>For example, see the difference to the creation of variable ’d’, which
is a constant variable.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">d</span> <span class="o">&lt;-</span> <span class="n">ln</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>                       <span class="err">#</span> <span class="n">assignment</span> <span class="n">of</span> <span class="n">constant</span> <span class="n">node</span> <span class="sc">'d'</span> <span class="n">with</span> <span class="n">the</span> <span class="n">value</span> <span class="k">if</span> <span class="n">the</span> <span class="n">logarithmic</span> <span class="n">function</span> <span class="n">with</span> <span class="n">parameter</span> <span class="sc">'b'</span>
<span class="n">d</span>                                <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="sc">'d'</span>
<span class="n">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>                           <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">information</span> <span class="n">of</span> <span class="sc">'d'</span>
</code></pre></div></div>

<p>Currently, the variables and have the same value. We can check this
using the equal comparison ().</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">e</span> <span class="o">:=</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span><span class="p">)</span>           
<span class="n">e</span>
</code></pre></div></div>

<p>Now, if we assign a new value to variable , then naturally the value of
changes. This has the consequence that all deterministic variables that
use ’a’ as a parameter, i.e., the variable , change their value
automatically too.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">&lt;-</span> <span class="mi">2</span>                           <span class="err">#</span> <span class="n">reassignment</span> <span class="n">of</span> <span class="n">variable</span> <span class="n">a</span><span class="p">;</span> <span class="n">every</span> <span class="n">deterministic</span> <span class="n">node</span> <span class="n">which</span> <span class="n">has</span> <span class="sc">'a'</span> <span class="n">as</span> <span class="n">a</span> <span class="n">parameter</span> <span class="n">changes</span> <span class="n">its</span> <span class="n">value</span>
<span class="n">a</span>                                <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="sc">'a'</span>
<span class="n">b</span>                                <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="sc">'b'</span>
<span class="n">c</span>                                <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="sc">'c'</span>
<span class="n">d</span>                                <span class="err">#</span> <span class="n">printing</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="sc">'d'</span>
<span class="n">e</span>
</code></pre></div></div>

<p>Since variable was a constant variable it did not change its value. This
also means that is now false.</p>

<p>Finally, we show you how to create the third type of variables in : the
stochastic variables. We will create a random variable from an
exponential distribution with parameter . Stochastic assignments use the
operation.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># Variable assignment: stochastic
</span><span class="n">lambda</span> <span class="o">&lt;-</span> <span class="mi">1</span>                      <span class="err">#</span> <span class="n">assign</span> <span class="n">constant</span> <span class="n">node</span> <span class="err">'</span><span class="n">lambda</span><span class="err">'</span> <span class="n">with</span> <span class="n">value</span> <span class="sc">'1'</span>
<span class="n">x</span> <span class="o">~</span> <span class="n">dnExponential</span><span class="p">(</span><span class="n">lambda</span><span class="p">)</span>        <span class="err">#</span> <span class="n">create</span> <span class="n">stochastic</span> <span class="n">node</span> <span class="n">with</span> <span class="n">exponential</span> <span class="n">distribution</span> <span class="n">and</span> <span class="n">parameter</span> <span class="err">'</span><span class="n">lambda</span><span class="err">'</span>
</code></pre></div></div>

<p>The value of is a random draw from the distribution. You can see the
value and the probability (or log-probability) of the current value
under the current parameter values by</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span>                                <span class="err">#</span> <span class="n">print</span> <span class="n">value</span> <span class="n">of</span> <span class="n">stochastic</span> <span class="n">node</span> <span class="sc">'x'</span>
<span class="n">x</span><span class="p">.</span><span class="n">probability</span><span class="p">()</span>                  <span class="err">#</span> <span class="n">print</span> <span class="n">the</span> <span class="n">probability</span> <span class="k">if</span> <span class="sc">'x'</span>
<span class="n">x</span><span class="p">.</span><span class="n">lnProbability</span><span class="p">()</span>                <span class="err">#</span> <span class="n">print</span> <span class="n">the</span> <span class="n">log</span><span class="o">-</span><span class="n">probability</span> <span class="k">if</span> <span class="sc">'x'</span>
<span class="n">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                           <span class="err">#</span> <span class="n">printing</span> <span class="n">all</span> <span class="n">the</span> <span class="n">information</span> <span class="n">of</span> <span class="sc">'x'</span>
</code></pre></div></div>

<p>Similarly, we create a random variable from a normal distribution by</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mu</span> <span class="o">&lt;-</span> <span class="mi">0</span>
<span class="n">sigma</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">~</span> <span class="n">dnNorm</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>    
<span class="n">y</span><span class="p">.</span><span class="n">probability</span><span class="p">()</span>                  <span class="err">#</span> <span class="n">print</span> <span class="n">the</span> <span class="n">probability</span> <span class="n">of</span> <span class="sc">'y'</span>
<span class="n">y</span><span class="p">.</span><span class="n">lnProbability</span><span class="p">()</span>                <span class="err">#</span> <span class="n">print</span> <span class="n">the</span> <span class="n">log</span><span class="o">-</span><span class="n">probability</span> <span class="k">if</span> <span class="sc">'y'</span>
<span class="n">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>                           <span class="err">#</span> <span class="n">printing</span> <span class="n">all</span> <span class="n">the</span> <span class="n">information</span> <span class="n">of</span> <span class="sc">'y'</span>
</code></pre></div></div>

<p>Variables that are not part of a model are assigned with , for example,
.</p>

<p>Now you know everything there is about creating the different types of
variables and the different ways in which these variables behave.</p>

<h3 id="simple-variable-manipulation-and-other-types-of-assignments">Simple variable manipulation and other types of assignments</h3>

<p>provides some convenience variable manipulation operations that are
equivalent to variable manipulations in other programming languages such
as C/C++, Java and Python. You can increment () and decrement () a
variable. The increment operation increases the current value of a
variable by 1 and the decrement operation decreases the value by 1. A
post increment () increases the value after returning the value, that
is, the old value is returned. A pre increment () increases the value
before returning the value, that is, the new value is returned.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">index</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="n">index</span><span class="o">++</span>                          <span class="err">#</span> <span class="n">post</span> <span class="n">increment</span>
<span class="o">++</span><span class="n">index</span>                          <span class="err">#</span> <span class="n">pre</span> <span class="n">increment</span>
<span class="n">index</span><span class="o">--</span>                          <span class="err">#</span> <span class="n">post</span> <span class="n">decrement</span>
<span class="o">--</span><span class="n">index</span>                          <span class="err">#</span> <span class="n">pre</span> <span class="n">decrement</span>
</code></pre></div></div>

<p>Additionally, you can use addition (), subtraction (), multiplication ()
and division () to an existing variable.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">index</span> <span class="o">+=</span> <span class="mi">10</span>                      <span class="err">#</span> <span class="n">add</span> <span class="mi">10</span> <span class="n">to</span> <span class="n">the</span> <span class="n">current</span> <span class="n">value</span>
<span class="n">index</span> <span class="o">*=</span> <span class="mi">2</span>                       <span class="err">#</span> <span class="kt">double</span> <span class="n">the</span> <span class="n">current</span> <span class="n">value</span>
</code></pre></div></div>

<p>These variable manipulations will come in very handy for indices of
vectors/arrays.</p>

<h3 id="vectors">Vectors</h3>

<p>Common values in are of scalar types. That means that not everything is
a vector by default. Instead, you can create a vector using three
different ways. First, you can call the vector function.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>                    <span class="err">#</span> <span class="n">create</span> <span class="n">a</span> <span class="n">vector</span>
</code></pre></div></div>

<p>Interestingly, we can use the same name for a variable as for a
function: the variable and the function . Both will still be fully
functional and our interpreter checks if you asked for a function or a
variable.</p>

<p>Second, you can use the square bracket notation.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">w</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>                     <span class="err">#</span> <span class="n">create</span> <span class="n">a</span> <span class="n">vector</span>
</code></pre></div></div>

<p>And third, you can implicitly create the vector by assigning elements.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;-</span><span class="mi">1</span>                         <span class="err">#</span> <span class="n">implicit</span> <span class="n">creation</span> <span class="n">of</span> <span class="n">a</span> <span class="n">vector</span>
<span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;-</span><span class="mi">2</span>                   
<span class="n">z</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;-</span><span class="mi">3</span>                  
</code></pre></div></div>

<p>The implicit creation does not need to instantiate the variable
beforehand. There are other useful built-in functions that produce
vectors.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="o">:</span><span class="mi">10</span>                             <span class="err">#</span> <span class="n">range</span> <span class="n">function</span>
<span class="n">rep</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>                        <span class="err">#</span> <span class="n">replicate</span> <span class="n">an</span> <span class="n">element</span> <span class="n">n</span> <span class="n">times</span>
<span class="n">seq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>                      <span class="err">#</span> <span class="n">built</span> <span class="n">a</span> <span class="n">sequence</span> <span class="n">from</span> <span class="n">a</span> <span class="n">to</span> <span class="n">b</span> <span class="n">by</span> <span class="n">c</span>
</code></pre></div></div>

<p>Vectors in belong to the class of objects that have methods. You can
call a member method by</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">.</span><span class="o">&lt;</span><span class="n">method</span> <span class="n">name</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;</span><span class="n">arguments</span><span class="o">&gt;</span><span class="p">)</span>                 
</code></pre></div></div>

<p>You have seen two methods previously, and . If you don’t remember what
the methods were called, or if this object has any member methods, then
you can get these by</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v</span><span class="p">.</span><span class="n">methods</span><span class="p">()</span>                 
</code></pre></div></div>

<p>In general, this is very, very useful. So for a vector we can get the
size — the number of elements — by calling its member function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>                 
</code></pre></div></div>

<h3 id="control-structures">Control Structures</h3>

<p>In this next part we will learn about control structures in . The first
control structure that we will look at is the loop. A loop executes a
single statement or a block of statements.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># loops
</span><span class="k">for</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">variable</span><span class="o">&gt;</span> <span class="n">in</span> <span class="o">&lt;</span><span class="n">set</span> <span class="n">of</span> <span class="n">value</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">&lt;</span><span class="n">single</span> <span class="n">statement</span><span class="o">&gt;</span>
 
<span class="k">for</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">variable</span><span class="o">&gt;</span> <span class="n">in</span> <span class="o">&lt;</span><span class="n">set</span> <span class="n">of</span> <span class="n">value</span><span class="o">&gt;</span><span class="p">)</span> 
   <span class="o">&lt;</span><span class="n">single</span> <span class="n">statement</span><span class="o">&gt;</span>

<span class="k">for</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">variable</span><span class="o">&gt;</span> <span class="n">in</span> <span class="o">&lt;</span><span class="n">set</span> <span class="n">of</span> <span class="n">value</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">&lt;</span><span class="n">multiple</span> <span class="n">statements</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">multiple</span> <span class="n">statements</span><span class="o">&gt;</span>
   <span class="o">&lt;</span><span class="n">multiple</span> <span class="n">statements</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The statement(s) will be executed for each value of variable of the
loop. A simple example is a loop that computes the sum of a sequence.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sum</span> <span class="o">&lt;-</span> <span class="mi">0</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="o">:</span><span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">sum</span> <span class="o">&lt;-</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">i</span>
<span class="p">}</span>
<span class="n">sum</span>
</code></pre></div></div>

<p>Another example using a loop is the computation of the <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci
number</a> for a given
integer.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># Fibonacci series using a for loop
</span><span class="n">fib</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="n">fib</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="n">in</span> <span class="mi">3</span><span class="o">:</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">fib</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">fib</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">fib</span>
</code></pre></div></div>

<p>We could also compute the Fibonacci numbers using a loop. The loop
continues to execute the statement(s) until the condition is wrong.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># Fibonacci series using a while loop
</span><span class="n">fib</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="n">fib</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="n">j</span> <span class="o">&lt;-</span> <span class="mi">3</span>
<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">fib</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">fib</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">fib</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
   <span class="n">j</span><span class="o">++</span>
<span class="p">}</span>
<span class="n">fib</span>
</code></pre></div></div>

<h3 id="user-defined-functions">User Defined Functions</h3>

<p>In you can write your own functions as well. The syntax for writing a
function is:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">function</span> <span class="o">&lt;</span><span class="k">return</span> <span class="n">value</span> <span class="n">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">name</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">list</span> <span class="n">of</span> <span class="n">arguments</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="o">&lt;</span><span class="n">statements</span><span class="o">&gt;</span> <span class="p">}</span>
</code></pre></div></div>

<p>As a simple example, let’s write a function that computes the square of
a number. We expect that the function takes in any real number. The type
of real number is . Since the square is always a positive real number,
we choose the return to be Now we can call our own function the same way
as we call other already built-in functions in .</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">&lt;-</span> <span class="n">square</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>
<span class="n">a</span>
</code></pre></div></div>

<p>As an exercise, let’s write a function that computes the factorial of a
natural number.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># function for computing the factorial
</span><span class="n">function</span> <span class="n">Natural</span> <span class="nf">fac</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">fac</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">1</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="n">b</span> <span class="o">&lt;-</span> <span class="n">fac</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">b</span>
</code></pre></div></div>

<p>Here you see that within your own function you can call your function as
well, which is commonly called recursive function calls.</p>

<p>Now let us write a recursive function for the sum of numbers which we
computed before using a loop.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># function for computing the sum
</span><span class="n">function</span> <span class="n">Integer</span> <span class="nf">sum</span><span class="p">(</span><span class="n">Integer</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">j</span> <span class="o">+</span> <span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">1</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="n">c</span> <span class="o">&lt;-</span> <span class="n">sum</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">c</span>
</code></pre></div></div>

<p>We can do the same for our favorite example, the Fibonacci series.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># function for computing the fibonacci series
</span><span class="n">function</span> <span class="n">Integer</span> <span class="nf">fib</span><span class="p">(</span><span class="n">Integer</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">k</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="n">d</span> <span class="o">&lt;-</span> <span class="n">fib</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">d</span>
</code></pre></div></div>

<p>Now that should be enough to get you going with our first example
analyses.</p>

<h1 id="exercise-poisson-regression-model-for-airline-fatalities">Exercise: Poisson Regression Model for Airline Fatalities</h1>

<p>This exercise will demonstrate how to approximate the posterior
distribution of some parameters using a simple Metropolis algorithm. The
focus here lies in the Metropolis algorithm, Bayesian inference, and
model specification—but not in the model or the data. After completing
this computer exercise, you should be familiar with the basic Metropolis
algorithm, analyzing output generated from a MCMC algorithm, and
performing standard Bayesian inference.</p>

<h2 id="model-and-data">Model and Data</h2>

<p>We will use the data example from <a href="#Gelman2003">(Gelman et al. 2003)</a>. A summary is given in
Table [tab:airlineFatalities].</p>

<hr />
<dl>
  <dt>Year           1976   1977   1978   1979   1980   1981   1982   1983   1984   1985</dt>
  <dt>  Fatalities       24     25     31     31     22     21     26     20     16     22</dt>
  <dt>  ———— —— —— —— —— —— —— —— —— —— ——</dt>
  <dd>
    <p>Airline fatalities from 1976 to 1985. Reproduced from <a href="#Gelman2003">(Gelman et al. 2003)</a>
  Table 2.2 on p. 69 %}.[]{data-label=”tab:airlineFatalities”}</p>
  </dd>
</dl>

<p>These data can be loaded into by typing:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">observed_fatalities</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">22</span><span class="p">)</span>
</code></pre></div></div>

<p>The model is a <a href="http://en.wikipedia.org/wiki/Poisson_regression">Poisson
regression</a> model with
parameters $\alpha$ and $\beta$
<script type="math/tex">y \sim \text{Poisson}(\exp(\alpha+\beta*x))</script> where $y$ is the number
of fatal accidents in year $x$. For simplicity, we choose uniform priors
for $\alpha$ and $\beta$. <script type="math/tex">% <![CDATA[
\begin{aligned}
\alpha & \sim & \text{Uniform}(-10,10)\\
\beta &  \sim & \text{Uniform}(-10,10)\end{aligned} %]]></script> The probability
density can be computed in for a single year by</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dpoisson</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</code></pre></div></div>

<h2 id="problems">Problems</h2>

<h3 id="metropolis-algorithm">Metropolis Algorithm</h3>

<p>The source file for this sub-exercise .</p>

<p>Let us construct a Metropolis algorithm that simulates from the
posterior distribution $P(\alpha,\beta|y)$. We will construct this
algorithm explicitly, without using the high-level functions existing in
to perform MCMC. In the next section, we will repeat the same analysis,
this time using the high-level functions. (More background on MCMC is
provided in the <a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_MCMC_Intro_Tutorial/RB_MCMC_Intro_Tutorial.pdf">Introduction to Markov Chain Monte Carlo Algorithms
tutorial</a>.)</p>

<p>For simplicity of the calculations you can “normalize” the years, e.g.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">&lt;-</span> <span class="mi">1976</span><span class="o">:</span><span class="mi">1985</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="mi">1976</span><span class="o">:</span><span class="mi">1985</span><span class="p">)</span>
</code></pre></div></div>

<p>A common proposal distribution for $\alpha^{\prime} \sim P(\alpha[i-1])$
is the normal distribution with mean $\mu = \alpha[i-1]$ and standard
deviation $\sigma = \delta_\alpha$:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha_prime</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">delta_alpha</span><span class="p">)</span>
</code></pre></div></div>

<p>A similar distribution should be used for $\beta^{\prime}$.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">delta_alpha</span> <span class="o">&lt;-</span> <span class="mf">1.0</span>
<span class="n">delta_beta</span> <span class="o">&lt;-</span> <span class="mf">1.0</span>
</code></pre></div></div>

<p>After you look at the output of the MCMC (later), play around to find
appropriate values for $\delta_{\alpha}$ and $\delta_{\beta}$.</p>

<p>Now we need to set starting values for the MCMC algorithm. Usually,
these are drawn from the prior distribution, but sometimes if the prior
is very uninformative, then these parameter values result in a
likelihood of 0.0 (or log-likelihood of -Inf).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="o">-</span><span class="mf">0.01</span>     <span class="err">#</span> <span class="n">you</span> <span class="n">can</span> <span class="n">also</span> <span class="n">use</span> <span class="n">runif</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="o">-</span><span class="mf">0.01</span>      <span class="err">#</span> <span class="n">you</span> <span class="n">can</span> <span class="n">also</span> <span class="n">use</span> <span class="n">runif</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">)</span>
</code></pre></div></div>

<p>Next, create some output for our MCMC algorithm. The output will be
written into a file that can be read into or Tracer <a href="#Rambaut2011">(Rambaut and Drummond 2011)</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># create a file output
</span><span class="n">write</span><span class="p">(</span><span class="s">"iteration"</span><span class="p">,</span><span class="s">"alpha"</span><span class="p">,</span><span class="s">"beta"</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="s">"airline_fatalities.log"</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">file</span><span class="o">=</span><span class="s">"airline_fatalities.log"</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="n">TRUE</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that we need a first iteration with value 0 so that Tracer can load
in this file.</p>

<p>Finally, we set up a loop over each iteration of the MCMC.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="mi">2</span><span class="o">:</span><span class="mi">10000</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div></div>

<p>Within the loop we propose new parameter values.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">alpha_prime</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">delta_alpha</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">beta_prime</span> <span class="o">&lt;-</span> <span class="n">rnorm</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">delta_beta</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>For the newly proposed parameter values we compute the prior ratio. In
this case we know that the prior ratio is 0.0 as long as the new
parameters are within the limits.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ln_prior_ratio</span> <span class="o">&lt;-</span> <span class="n">dunif</span><span class="p">(</span><span class="n">alpha_prime</span><span class="p">,</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">+</span> <span class="n">dunif</span><span class="p">(</span><span class="n">beta_prime</span><span class="p">,</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-</span> <span class="n">dunif</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">-</span> <span class="n">dunif</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="n">log</span><span class="o">=</span><span class="n">TRUE</span><span class="p">)</span>
</code></pre></div></div>

<p>Similarly, we compute the likelihood ratio for each observation.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ln_likelihood_ratio</span> <span class="o">&lt;-</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="n">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
       <span class="n">lambda_prime</span> <span class="o">&lt;-</span> <span class="n">exp</span><span class="p">(</span> <span class="n">alpha_prime</span> <span class="o">+</span> <span class="n">beta_prime</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
       <span class="n">lambda</span> <span class="o">&lt;-</span> <span class="n">exp</span><span class="p">(</span> <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span>
       <span class="n">ln_likelihood_ratio</span> <span class="o">+=</span> <span class="n">dpoisson</span><span class="p">(</span><span class="n">observed_fatalities</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">lambda_prime</span><span class="p">)</span> <span class="o">-</span> <span class="n">dpoisson</span><span class="p">(</span><span class="n">observed_fatalities</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">lambda</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">ratio</span> <span class="o">&lt;-</span> <span class="n">ln_prior_ratio</span> <span class="o">+</span> <span class="n">ln_likelihood_ratio</span>
</code></pre></div></div>

<p>And finally we accept or reject the newly proposed parameter values with
probability .</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span> <span class="n">ln</span><span class="p">(</span><span class="n">runif</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">ratio</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">alpha_prime</span>
       <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">beta_prime</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
       <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Then we log the current parameter values to the file by appending the
file.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp"># output to a log-file
</span>    <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">file</span><span class="o">=</span><span class="s">"airline_fatalities.log"</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="n">TRUE</span><span class="p">)</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>As a quick summary you can compute the posterior mean of the parameters.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mean</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="n">mean</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
</code></pre></div></div>

<p>You can also load the file into or Tracer to analyze the output.</p>

<p>In this section of the first exercise we wrote our own little Metropolis
algorithm in . This becomes very cumbersome, difficult and slow if we’ld
need to do this for every model. Here we wanted to show you only the
basic principle of any MCMC algorithm. In the next section we will use
the built-in MCMC algorithm of .</p>

<h3 id="mcmc-analysis-using-the-built-in-algorithm-in">MCMC analysis using the built-in algorithm in</h3>

<p>Before starting with this new approach it would be good if you either
start a new session or clear all previous variables using the function.
Currently we may have some minor memory problems and if you get stuck it
may help to restart .</p>

<p>We start by loading in the data to .</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">observed_fatalities</span> <span class="o">&lt;-</span> <span class="n">v</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">22</span><span class="p">)</span>
<span class="n">x</span> <span class="o">&lt;-</span> <span class="mi">1976</span><span class="o">:</span><span class="mi">1985</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="mi">1976</span><span class="o">:</span><span class="mi">1985</span><span class="p">)</span>
</code></pre></div></div>

<p>Then we create the parameters with their prior distributions.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alpha</span> <span class="o">~</span> <span class="n">dnUnif</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> 
<span class="n">beta</span> <span class="o">~</span> <span class="n">dnUnif</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>It may be good to set some reasonable starting values especially if you
choose a very uninformative prior distribution. If by chance you had
starting values that gave a likelihood of -Inf, then will try several
times to propose new starting values drawn from the prior distribution.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># let us use reasonable starting value
</span><span class="n">alpha</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">beta</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</code></pre></div></div>

<p>Our next step is to set up the moves. Moves are algorithms that propose
new values and know how to reset the values if the proposals are
rejected. We use the same sliding window move as we implemented above by
ourselves.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mi</span> <span class="o">&lt;-</span> <span class="mi">0</span>
<span class="n">moves</span><span class="p">[</span><span class="n">mi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mvSlide</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="n">moves</span><span class="p">[</span><span class="n">mi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mvSlide</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
</code></pre></div></div>

<p>Then we set up the model. This means we create a stochastic variable for
each observation and clamp its value with the observed data.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">lambda</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">exp</span><span class="p">(</span> <span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">~</span> <span class="n">dnPoisson</span><span class="p">(</span><span class="n">lambda</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clamp</span><span class="p">(</span><span class="n">observed_fatalities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can now create the model by pulling up the model graph from any
variable that is connected to our model graph.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mymodel</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span> <span class="n">alpha</span> <span class="p">)</span>
</code></pre></div></div>

<p>We also need some monitors that report the current values during the
MCMC run. We create two monitors, one printing all numeric non-constant
variables to a file and one printing some information to the screen.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">monitors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mnModel</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">"output/airline_fatalities.log"</span><span class="p">,</span><span class="n">printgen</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">separator</span> <span class="o">=</span> <span class="s">"   "</span><span class="p">)</span>
<span class="n">monitors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mnScreen</span><span class="p">(</span><span class="n">printgen</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
</code></pre></div></div>

<p>Finally we create an MCMC object. The MCMC object takes in a model
object, the vector of monitors and the vector of moves.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mymcmc</span> <span class="o">=</span> <span class="n">mcmc</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span> <span class="n">monitors</span><span class="p">,</span> <span class="n">moves</span><span class="p">)</span>
</code></pre></div></div>

<p>On the MCMC object we call its member method to run the MCMC.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mymcmc</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="mi">3000</span><span class="p">)</span>
</code></pre></div></div>

<p>And now we are done</p>

<h3 id="posterior-distribution-of-alpha-and-beta">Posterior Distribution of $\alpha$ and $\beta$</h3>

<p>Report the posterior mean and 95% credible intervals for $\alpha$ and
$\beta$. Additionally, plot the posterior distribution of $\alpha$ and
$\beta$ by plotting a histogram of the samples. Plot the curve of
$m(x) = \text{E}[\exp(\alpha+\beta<em>x)|y]$ for $x = [1976,1985]$. You can
generate draws from the posterior distribution of the expected value for
a specific $x$ by recording the current expected value at a iteration
$i$ of the Metropolis algorithm
$m_sample(x)[i] = \text{E}[\exp(\alpha[i]+\beta[i]</em>x)|y]$ and taking
the mean of those samples () afterwards. Since provides you with the
samples of $m(x) = \text{E}[\exp(\alpha+\beta*x)|y] = \lambda_x$ you can
simply plot these posterior curves.</p>

<p>Produce a histogram of the predictive distribution of the number of
fatalities in 2014 and estimate the posterior mean. The predictive
distribution can be approximated simultaneously with the Metropolis
algorithm. This means, for any iteration $i$ you simulate draws from the
conditional distribution for $x = 2014$ and the current values of
$\alpha[i]$ and $\beta[i]$.</p>

<p>Estimate the distribution of the mean of the posterior predictive
distribution of the the number of fatalities in 2014. Therefore, let us
denote the expected value of the posterior distribution by $\mu$. Since
we do not know this value $\mu$ exactly, we can follow the Bayesian
approach and associate a probability for each value $m$ as being the
true expected value of the posterior distribution, given the
observations $y$ ($P(m = \mu|y)$). You can approximate this distribution
by recording the expected value for the number of fatalities in 2014
($\text{E}[\exp(\alpha+\beta*x)|y]$) in each iteration $i$ of the
Metropolis algorithm. Plot a histogram of the expected values, compute
the mean of the expected values and compare it to the previously
obtained estimate of the mean of the posterior predictive distribution.</p>

<p>Follow the same approach as for the posterior predictive distribution
for $x = 2014$, but this time for $x = 2016$ and estimate the
probability of no fatality.</p>

<h1 id="exercise-poisson-regression-model-for-coal-mine-accidents">Exercise: Poisson Regression Model for Coal-mine Accidents</h1>

<p>We will analyze a dataset coal-mine accidents. The values are the dates
of major (more than 10 casualties) coal-mining disasters in the UK from
1851 to 1962.</p>

<h2 id="a-model-for-disasters">A model for disasters</h2>

<p>A common model for the number of events that occur over a period of time
is a Poisson process, in which the numbers of events in disjoint
time-intervals are independent and Poisson-distributed. We will
discretize and look at the yearly number of accidents.</p>

<p>In order to take into account the possible change of rate, we will allow
for different rates before and after year $\theta$, where $\theta$ is
unknown to us. Thus, the observation distribution of our model is
$y_t \sim Poisson(\lambda_t)$ with $t = 1851,\ldots,1962$ and
<script type="math/tex">% <![CDATA[
\begin{aligned}
\lambda_t & = & \begin{cases}
\beta & \mbox{if } t < \theta \\
\gamma & \mbox{if } t \geq \theta
\end{cases}\end{aligned} %]]></script> Thus, the rate $\lambda_t$ is defined by
three unknown parameters: $\beta$, $\gamma$ and $\theta$. A hierarchical
choice of priors is given by <script type="math/tex">% <![CDATA[
\begin{aligned}
 \eta & \sim & Gamma(10.0;20.0) \\ 
 \beta & \sim & Gamma(2.0;\eta) \\
 \gamma & \sim &Gamma(2.0;\eta) \\
 \theta & \sim & Uniform(1852,\ldots,1962)\end{aligned} %]]></script> which brings
an additional parameter $\eta$ in the model. For $\theta$ we have used a
uniform prior over the years, but excluded year 1851 in order to make
sure at least one year has rate $\beta$. The hierarchical prior carries
the belief that $\beta$ and $\gamma$ are somewhat similar in size, since
they both depend on $\eta$.</p>

<h2 id="the-model-in--the-model-in-unnumbered">The model in  {#the-model-in .unnumbered}</h2>

<p>We start as usual by loading in the data.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">observed_fatalities</span> <span class="o">&lt;-</span>  <span class="n">v</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">year</span> <span class="o">&lt;-</span> <span class="mi">1851</span><span class="o">:</span><span class="mi">1962</span>
</code></pre></div></div>

<p>In we specify this prior choice by</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eta</span> <span class="o">~</span> <span class="n">dnGamma</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span><span class="mf">20.0</span><span class="p">)</span>
<span class="n">beta</span> <span class="o">~</span> <span class="n">dnGamma</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
<span class="n">gamma</span> <span class="o">~</span> <span class="n">dnGamma</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
<span class="n">theta</span> <span class="o">~</span> <span class="n">dnUnif</span><span class="p">(</span><span class="mf">1852.0</span><span class="p">,</span><span class="mf">1962.0</span><span class="p">)</span>
</code></pre></div></div>

<p>Then we select moves for each parameter. For the rate parameters — which
are defined only on the positive real line — we choose a scaling move.
Only for we choose the sliding window proposal.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mi</span> <span class="o">&lt;-</span> <span class="mi">0</span>
<span class="n">moves</span><span class="p">[</span><span class="n">mi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mvScale</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span>
<span class="n">moves</span><span class="p">[</span><span class="n">mi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mvScale</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
<span class="n">moves</span><span class="p">[</span><span class="n">mi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mvScale</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
<span class="n">moves</span><span class="p">[</span><span class="n">mi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mvSlide</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
</code></pre></div></div>

<p>Then, we set up the model by computing the conditional rate of the
Poisson distribution, creating random variables for each observation and
attaching (clamping) data to the variables.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">year</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">rate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">ifelse</span><span class="p">(</span><span class="n">theta</span> <span class="o">&gt;</span> <span class="n">year</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">~</span> <span class="n">dnPoisson</span><span class="p">(</span><span class="n">rate</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clamp</span><span class="p">(</span><span class="n">observed_fatalities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, we create the model object from the variables, add some
monitors and run the MCMC algorithm.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mymodel</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span> <span class="n">theta</span> <span class="p">)</span>

<span class="n">monitors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mnModel</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">"output/coal_accidents.log"</span><span class="p">,</span><span class="n">printgen</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">separator</span> <span class="o">=</span> <span class="s">"   "</span><span class="p">)</span>
<span class="n">monitors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mnScreen</span><span class="p">(</span><span class="n">printgen</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">lambda</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

<span class="n">mymcmc</span> <span class="o">=</span> <span class="n">mcmc</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span> <span class="n">monitors</span><span class="p">,</span> <span class="n">moves</span><span class="p">)</span>

<span class="n">mymcmc</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="mi">3000</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="batch-mode">Batch Mode</h2>

<p>If you wish to run this exercise in batch mode, the files are provided
for you.</p>

<p>You can carry out these batch commands by providing the file name when
you execute the binary in your unix terminal (this will overwrite all of
your existing run files).</p>
