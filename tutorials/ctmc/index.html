<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- meta "search-domain" used for google site search function google_search() -->
    <meta name="search-domain" value="/revbayes_tutorials">
    <link rel="stylesheet" href="/revbayes_tutorials/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/revbayes_tutorials/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/revbayes_tutorials/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/revbayes_tutorials/assets/css/main.css" />
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->
    <title>RevBayes Tutorials: Phylogenetic Inference using ‘RevBayes‘</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a href="https://revbayes.github.io" class="pull-left">
        <img class="navbar-logo" src="/revbayes_tutorials/assets/img/aquabayes.png" alt="RevBayes logo" />
      </a>
      
      
      <a class="navbar-brand" href="/revbayes_tutorials/">Home</a>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">

	
        <li><a href="/revbayes_tutorials/software/">Software</a></li>
        <li><a href="/revbayes_tutorials/developer/">Developer</a></li>
        <li><a href="/revbayes_tutorials/tutorials/">Tutorials</a></li>
        <li><a href="/revbayes_tutorials/workshops/">Workshops</a></li>
      </ul>
      <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form>
    </div>
  </div>
</nav>

      <div class="row">
	<h1 class="maintitle">Phylogenetic Inference using ‘RevBayes‘</h1>
	<h3 class="subtitle">Substitution Models</h3>
	<h4 class="maintitle">Sebastian H&#246;hna, Michael Landis, Brian Moore and Tracy Heath</h4>
</div>

      
<blockquote class="overview no-print" id="overview">
  <h2>Overview</h2>
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            
            
            <li><a href="/revbayes_tutorials/tutorials/intro/">Statistical Inference Using RevBayes</a></li>
          
          </ul>
        
    </div>
  </div>
</blockquote>

<blockquote class="tutorial_files no-print">
  <h2>Data files and scripts</h2>
  
    <div class="row">
      <div class="col-md-9">
          <strong>Scripts</strong>
          <ul id="scripts"></ul>
        </div>
    </div>
</blockquote>
      <h1 class="section" id="overview">Overview</h1>

<p>This tutorial provides the first protocol from our recent publication
<a href="#Hoehna2017a">(Höhna et al. 2017)</a>. The second protocol is described in the <a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_Partition_Tutorial/RB_Partition_Tutorial.pdf">Partitioned
data analysis
tutorial</a>
and the third protocol is described in the <a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_BayesFactor_Tutorial/RB_BayesFactor_Tutorial.pdf">Bayes factor
tutorial</a>.</p>

<p>The present tutorial demonstrates how to set up and perform analyses
using common nucleotide substitution models. The substitution models
used in molecular evolution are continuous time Markov models, which are
fully characterized by their instantaneous-rate matrix:</p>

<script type="math/tex; mode=display">% <![CDATA[
Q = \begin{pmatrix} -\mu_A & \mu_{GA} & \mu_{CA} & \mu_{TA} \\
\mu_{AG} & -\mu_G  & \mu_{CG} & \mu_{TG} \\
\mu_{AC} & \mu_{GC} & -\mu_C  & \mu_{TC} \\
\mu_{AT} & \mu_{GT} & \mu_{CT} & -\mu_T 
\end{pmatrix} \mbox{  ,} %]]></script>

<p>where $\mu_{ij}$ represents the instantaneous rate of substitution from
state $i$ to state $j$. The diagonal elements $\mu_i$ are the rates of
<em>not</em> changing out of state $i$, equal to the sum of the elements in the
corresponding row. Given the instantaneous-rate matrix, $Q$, we can
compute the corresponding transition probabilities for a branch of
length $t$, $P(t)$, by exponentiating the rate matrix:</p>

<script type="math/tex; mode=display">% <![CDATA[
P(t) = \begin{pmatrix}          
p_{AA}(t) & p_{GA}(t) & p_{CA}(t) & p_{TA}(t) \\
p_{AG}(t) & p_{GG}(t) & p_{CG}(t) & p_{TG}(t) \\
p_{AC}(t) & p_{GC}(t) & p_{CC}(t) & p_{TC}(t) \\
p_{AT}(t) & p_{GT}(t) & p_{CT}(t) & p_{TT}(t)
\end{pmatrix} = e^{Qt} = \sum_{j=0}^\infty\frac{tQ^j}{j!} \mbox{  .} %]]></script>

<p>Each specific substitution model has a uniquely defined
instantaneous-rate matrix, $Q$.</p>

<p>In this tutorial you will perform phylogeny inference under common
models of DNA sequence evolution: JC, F81, HKY85, GTR, GTR+Gamma and
GTR+Gamma+I. For all of these substitution models, you will perform an
MCMC analysis to estimate phylogeny and other model parameters. The
estimated trees will be unrooted trees with independent branch-length
parameters. We will provide comments on how to modify the tutorial if
you wish to estimate rooted, clock-like trees. All the assumptions will
be covered more in detail later in this tutorial.</p>

<h2 id="requirements">Requirements</h2>

<p>We assume that you have read and hopefully completed the following
tutorials:</p>

<ul>
  <li>
    <p><a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_Getting_Started/RB_Getting_Started.pdf">Getting Started with
‘RevBayes‘</a></p>
  </li>
  <li>
    <p><a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_Intro_Tutorial/RB_Intro_Tutorial.pdf">Very Basic Introduction to
‘Rev‘</a></p>
  </li>
  <li>
    <p><a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_Rev_Tutorial/RB_Rev_Tutorial.pdf">General Introduction to the ‘Rev‘
syntax</a></p>
  </li>
  <li>
    <p><a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_MCMC_Archery_Tutorial/RB_MCMC_Archery_Tutorial.pdf">General Introduction to MCMC using an archery
example</a></p>
  </li>
  <li>
    <p><a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_MCMC_Binomial_Tutorial/RB_MCMC_Binomial_Tutorial.pdf">General Introduction to MCMC using a coin-flipping
example</a></p>
  </li>
</ul>

<p>Note that the <a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_Intro_Tutorial/RB_Intro_Tutorial.pdf">‘Rev‘ basics
tutorial</a>
introduces the basic syntax of ‘Rev‘ but does not cover any phylogenetic
models. We tried to keep this tutorial very basic and introduce all the
language concepts and theory on the way. You may only need the <a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_Rev_Tutorial/RB_Rev_Tutorial.pdf">‘Rev‘
syntax
tutorial</a>
for a more in-depth discussion of concepts in ‘Rev‘.</p>

<h1 class="section" id="data-and-files">Data and files</h1>

<p>We provide the data file(s) which we will use in this tutorial. You may
want to use your own data instead. In the ‘data‘ folder, you will find
the following files</p>

<ul>
  <li>‘primates_and_galeopterus_cytb.nex‘: Alignment of the <em>cytochrome
b</em> subunit from 23 primates representing 14 of the 16 families
(<em>Indriidae</em> and <em>Callitrichidae</em> are missing). Note that there is
one outgroup species included: <em>Galeopterus variegatus</em>.</li>
</ul>

<h1 class="section" id="example-character-evolution-under-the-jukes-cantor-substitution-model">Example: Character Evolution under the Jukes-Cantor Substitution Model</h1>

<h2 id="getting-started">Getting Started</h2>

<p>The first section of this exercise involves: (1) setting up a
Jukes-Cantor (JC) substitution model for an alignment of the cytochrome
b subunit; (2) approximating the posterior probability of the tree
topology and node ages (and all other parameters) using MCMC, and; (3)
summarizing the MCMC output by computing the maximum <em>a posteriori</em>
tree.</p>

<p><img src="figures/jc_graphical_model.png" alt="" /></p>
<blockquote>
  <p>Graphical model
representation of a simple phylogenetic model. The graphical model shows
the dependencies between the parameters.Here, the rate matrix $Q$ is a
constant variable because it is fixed and does not depend on any
parameters.The only free parameters of this model, the Jukes-Cantor
model, are the tree $\Psi$ including the node ages.</p>
</blockquote>

<p>We first consider the simplest substitution model described by
<a href="#Jukes1969">(Jukes and Cantor 1969)</a>. The instantaneous-rate matrix for the JC substitution
model is defined as</p>

<script type="math/tex; mode=display">% <![CDATA[
Q_{JC69} = \begin{pmatrix} 
{*} & \frac{1}{3} & \frac{1}{3} & \frac{1}{3} \\ 
\frac{1}{3} & {*} & \frac{1}{3} & \frac{1}{3} \\ 
\frac{1}{3} & \frac{1}{3} & {*} & \frac{1}{3} \\ 
\frac{1}{3} & \frac{1}{3} & \frac{1}{3} & {*}  
\end{pmatrix} \mbox{  ,} %]]></script>

<p>which has the advantage that the transition probability matrix can be
computed analytically</p>

<script type="math/tex; mode=display">% <![CDATA[
P_{JC69} = \begin{pmatrix} {\frac{1}{4} + \frac{3}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} + \frac{3}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} + \frac{3}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} - \frac{1}{4}e^{-rt}} & {\frac{1}{4} + \frac{3}{4}e^{-rt}}  
\end{pmatrix} \mbox{  ,} %]]></script>

<p>where $t$ is the branch length in units of time, and $r$ is the rate
(clock) for the process. In the later exercises you will be asked to
specify more complex substitution models. <strong>Don’t worry, you won’t have
to calculate all of the transition probabilities, because ‘RevBayes‘
will take care of all the computations for you.</strong> Here we only provide
some of the equations for the models in case you might be interested in
the details. You will be able to complete the exercises without
understanding the underlying math.</p>

<p>\
The files for this example analysis are provided for you, which can
easily be run using the ‘source()‘ function in the ‘RevBayes‘ console:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mcmc_JC.Rev")
</code></pre></div></div>

<p>If everything loaded properly, then you should see the program initiate
the Markov chain Monte Carlo analysis that estimates the posterior
distribution. If you continue to let this run, then you will see it
output the states of the Markov chain once the MCMC analysis begins.</p>

<p>Ultimately, this is how you will execute most analyses in ‘RevBayes‘,
with the full specification of the model and analyses contained in the
sourced files. You could easily run this entire analysis on your own
data by substituting your data file name for that in the
model-specification file. However, it is important to understand the
components of the model to be able to take full advantage of the
flexibility and richness of ‘RevBayes‘. Furthermore, without inspecting
the ‘Rev‘ scripts sourced in ‘mcmc_JC.Rev‘, you may end up
inadvertently performing inappropriate analyses on your dataset, which
would be a waste of your time and CPU cycles. The next steps will walk
you through the full specification of the model and MCMC analyses.</p>

<h2 id="loading-the-data">Loading the Data</h2>

<p>\
Download data and output files (if you don’t have them already) from:\
<a href="http://revbayes.github.io/tutorials.html">http://revbayes.github.io/tutorials.html</a></p>

<p>First load in the sequences using the ‘readDiscreteCharacterData()‘
function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data &lt;- readDiscreteCharacterData("data/primates_and_galeopterus_cytb.nex")
</code></pre></div></div>

<p>Executing these lines initializes the data matrix as the respective
‘Rev‘ variables. To report the current value of any variable, simply
type the variable name and press enter. For the ‘data‘ matrix, this
provides information about the alignment:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data
</code></pre></div></div>

<div class="console highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       DNA character matrix with 23 taxa and 1141 characters
       =====================================================
       Origination:                      primates_and_galeopterus_cytb.nex
       Number of taxa:                   23
       Number of included taxa:          23
       Number of characters:             1141
       Number of included characters: 1141
       Datatype:                         DNA
</code></pre></div></div>

<p>Next we will specify some useful variables based on our dataset. The
variable ‘data‘ has <em>member functions</em> that we can use to retrieve
information about the dataset. These include, for example, the number of
species and the taxa. We will need that taxon information for setting up
different parts of our model.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_species &lt;- data.ntaxa()
n_branches &lt;- 2 * n_species - 3
taxa &lt;- data.taxa()
</code></pre></div></div>

<p>Additionally, we set up a counter variable for the number of moves that
we already added to our analysis. [Recall that moves are algorithms
used to propose new parameter values during the MCMC simulation.] This
will make it much easier if we extend the model or analysis to include
additional moves or to remove some moves. Similarly, we set up a counter
variable for the number of monitors. [Monitors print the values of
model parameters to the screen and/or log files during the MCMC
analysis].</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvi = 1 
mni = 1
</code></pre></div></div>

<p>You may have noticed that we used the ‘=‘ operator to create the move
index. This simply means that the variable is not part of the model. You
will later see that we use this operator more often,
<em>e.g.,</em>when we create moves and monitors.</p>

<p>With the data loaded, we can now proceed to specify our Jukes-Cantor
substitution model.</p>

<h2 id="jukes-cantor-substitution-model">Jukes-Cantor Substitution Model</h2>

<p>A given substitution model is defined by its corresponding
instantaneous-rate matrix, $Q$. The Jukes-Cantor substitution model does
not have any free parameters (as the substitution rates are all assumed
to be equal, and there is a separate parameter that scales their overall
magnitude), so we can define it as a constant variable. The function
‘fnJC(n)‘ will create an instantaneous-rate matrix for a character with
$n$ states. Since we use DNA data here, we create a 4x4
instantaneous-rate matrix:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q &lt;- fnJC(4) 
</code></pre></div></div>

<p>You can see the rates of the $Q$ matrix by typing</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q
</code></pre></div></div>

<div class="console highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       [ [ -1.0000, 0.3333, 0.3333, 0.3333 ] ,
         0.3333, -1.0000, 0.3333, 0.3333 ] ,
         0.3333, 0.3333, -1.0000, 0.3333 ] ,
         0.3333, 0.3333, 0.3333, -1.0000 ] ]
</code></pre></div></div>

<p>As you can see, all substitution rates are equal.</p>

<h2 id="tree-topology-and-branch-lengths">Tree Topology and Branch Lengths</h2>

<p>The tree topology and branch lengths are stochastic nodes in our
phylogenetic model. In Figure [fig:jc], the tree topology is denoted
$\Psi$ and the length of the branch leading to node $i$ is $bl_i$.</p>

<p>We will assume that all possible labeled, unrooted tree topologies have
equal probability. This is the ‘dnUniformTopology()‘ distribution in
‘RevBayes‘. Note that in ‘RevBayes‘ it is advisable to specify the
outgroup for your study system if you use an unrooted tree prior,
whereas other software,
<em>e.g.,</em><code class="highlighter-rouge">MrBayes</code>uses the first
taxon in the data matrix file as the outgroup. Specify the ‘topology‘
stochastic node by passing in the tip labels ‘names‘ to the
‘dnUniformTopology()‘ distribution:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>out_group = clade("Galeopterus_variegatus")
topology ~ dnUniformTopology(taxa, outgroup=out_group)
</code></pre></div></div>

<p>Some types of stochastic nodes can be updated by a number of alternative
moves. Different moves may explore parameter space in different ways,
and it is possible to use multiple different moves for a given parameter
to improve mixing (the efficiency of the MCMC simulation). In the case
of our unrooted tree topology, for example, we can use both a
nearest-neighbor interchange move (‘mvNNI‘) and a subtree-prune and
regrafting move (‘mvSPR‘). These moves do not have tuning parameters
associated with them, thus you only need to pass in the ‘topology‘ node
and proposal ‘weight‘.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvNNI(topology, weight=1.0)
moves[mvi++] = mvSPR(topology, weight=1.0)
</code></pre></div></div>

<p>The weight specifies how often the move will be applied either on
average per iteration or relative to all other moves. Have a look at the
<a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_MCMC_Tutorial/RB_MCMC_Tutorial.pdf">MCMC Diagnosis
tutorial</a>
for more details about moves and MCMC strategies (found on the
<a href="http://revbayes.github.io/tutorials.html">‘RevBayes‘ Tutorials
Website</a>).</p>

<p>Next we have to create a stochastic node for each of the $2N-3$ branches
in our tree (where $N=$ ‘n_species‘). We can do this using a ‘for‘ loop
— this is a plate in our graphical model. In this loop, we can create
each of the branch-length nodes and assign each move. Copy this entire
block of ‘Rev‘ code into the console:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_branches) {
   br_lens[i] ~ dnExponential(10.0)
   moves[mvi++] = mvScale(br_lens[i]) 
}
</code></pre></div></div>

<p>It is convenient for monitoring purposes to add the tree length as
deterministic variable. The tree length is simply the sum of all branch
lengths. Accordingly, the tree length can be computed using the ‘sum()‘
function, which calculates the sum of any vector of values.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TL := sum(br_lens)
</code></pre></div></div>

<p><strong>Alternative branch-length priors</strong>\
Some studies,
<em>e.g.,</em>(missing reference), have
criticized the exponential prior distribution for branch lengths because
it induces a gamma-dsitributed tree-length and the mean of this gamma
distribution grows with the number of taxa. For example, we can use
instead a specific gamma prior distribution (or any other distribution
defined on a positive real variable) for the tree length, and then use a
Dirichlet prior distribution to break the tree length into the
corresponding branch lengths <a href="#Zhang2012">(Zhang et al. 2012)</a>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># specify a prior distribution on the tree length with your desired mean
TL ~ dnGamma(2,4)
moves[mvi++] = mvScale(TL) 

# now create a random variable for the relative branch lengths
rel_branch_lengths ~ dnDirichlet( rep(1.0,n_branches) )
moves[mvi++] = mvBetaSimplex(rel_branch_lengths, weight=n_branches)
moves[mvi++] = mvDirichletSimplex(rel_branch_lengths, weight=n_branches/10.0)

# finally, transform the relative branch lengths into actual branch lengths
br_lens := rel_branch_lengths * TL
</code></pre></div></div>

<p>Finally, we can create a <em>phylogram</em> (a phylogeny in which the branch
lengths are proportional to the expected number of substitutions/site)
by combining the tree topology and branch lengths. We do this using the
‘treeAssembly()‘ function, which applies the value of the $i^{th}$
member of the ‘br_lens‘ vector to the branch leading to the $i^{th}$
node in ‘topology‘. Thus, the ‘psi‘ variable is a deterministic node:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi := treeAssembly(topology, br_lens)
</code></pre></div></div>

<p><strong>Alternative Analysis\
Prior on Time-Trees: Tree Topology and Node Ages</strong>\
Alternatively, you may want to specify a prior on time-trees. Here we
will briefly indicate how to specify such an prior which will lead to
inference of time trees.</p>

<p>The tree (the topology and node ages) is a stochastic node in our
phylogenetic model. For simplicity, we will assume a uniform prior on
both topologies and node ages. The distribution in ‘RevBayes‘ is
‘dnUniformTimeTree()‘.</p>

<p>Fore more information on tree priors, such as birth-death
processes, please read the
<a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_DiversificationRate_Tutorial/RB_DiversificationRate_Tutorial.pdf">RB_DiversificationRate_Tutorial</a>.</p>

<p>First, we need to specify the age of the tree:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root_age &lt;- 10.0
</code></pre></div></div>

<p>Here we simply assumed that the tree is 10.0 time units old. We could
also specify a prior on the root age if we have fossil calibrations (see
<a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_DivergenceTime_Calibration_Tutorial/RB_DivergenceTime_Calibration_Tutorial.pdf">Divergence Time and Calibration
Tutorial</a>).
Next, we specify the ‘tree‘ stochastic variable by passing in the taxon
information ‘taxa‘ to the ‘dnUniformTimeTree()‘ distribution:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi ~ dnUniformTimeTree(rootAge=root_age, taxa=taxa)
</code></pre></div></div>

<p>Some types of stochastic nodes can be updated by a number of alternative
moves. Different moves may explore parameter space in different ways,
and it is possible to use multiple different moves for a given parameter
to improve mixing (the efficiency of the MCMC simulation). In the case
of our rooted tree, for example, we can use both a nearest-neighbor
interchange move without and with changing the node ages (‘mvNarrow‘ and
‘mvNNI‘) and a fixed-nodeheight subtree-prune and regrafting move
(‘mvFNPR‘) and its Metropolized-Gibbs variant (‘mvGPR‘)
(missing reference). We also need moves that change the ages of
the internal nodes, for example, ‘mvSubtreeScale‘ and
‘mvNodeTimeSlideUniform‘. These moves do not have tuning parameters
associated with them, thus you only need to pass in the ‘psi‘ node and
proposal ‘weight‘.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvNarrow(psi, weight=5.0)
moves[mvi++] = mvNNI(psi, weight=1.0)
moves[mvi++] = mvFNPR(psi, weight=3.0)
moves[mvi++] = mvGPR(psi, weight=3.0)
moves[mvi++] = mvSubtreeScale(psi, weight=3.0)
moves[mvi++] = mvNodeTimeSlideUniform(psi, weight=15.0)
</code></pre></div></div>

<p>The weight specifies how often the move will be applied either on
average per iteration or relative to all other moves. Have a look at the
MCMC tutorial for more details about moves and MCMC strategies:
<a href="http://revbayes.github.io/tutorials.html">http://revbayes.github.io/tutorials.html</a></p>

<p><strong>Molecular clock</strong>\
Additionally, in the case of time-calibrated trees, we need to add a
molecular clock rate parameter. For example, we know from empirical
estimates that the molecular clock rate is about 0.01 (=1%) per million
years per site. Nevertheless, we can estimate it here because we fixed
the root age. We use a uniform prior on the log-transform clock rate.
This specifies our lack of prior knowledge on the magnitude of the clock
rate.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log_clock_rate ~ dnUniform(-6,1)
moves[mvi++] = mvSlide(log_clock_rate, weight=2.0)
clock_rate := 10^log_clock_rate
</code></pre></div></div>

<p>Instead, you could also fix the clock rate and estimate the root age.
Fore more information on molecular clocks please read the
<a href="https://github.com/revbayes/revbayes_tutorial/raw/master/tutorial_TeX/RB_DivergenceTime_Tutorial/RB_DivergenceTime_Tutorial.pdf">RB_DivergenceTime_Tutorial</a>.</p>

<h2 id="putting-it-all-together">Putting it All Together</h2>

<p>We have fully specified all of the parameters of our phylogenetic
model—the tree topology with branch lengths, and the substitution model
that describes how the sequence data evolved over the tree with branch
lengths. Collectively, these parameters comprise a distribution called
the <em>phylogenetic continuous-time Markov chain</em>, and we use the
‘dnPhyloCTMC‘ constructor function to create this node. This
distribution requires several input arguments: (1) the ‘tree‘ with
branch lengths; (2) the instantaneous-rate matrix ‘Q‘; (3) the ‘type‘ of
character data.</p>

<p>Build the random variable for the character data (sequence alignment).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># the sequence evolution model
seq ~ dnPhyloCTMC(tree=psi, Q=Q, type="DNA")
</code></pre></div></div>

<p>Once the ‘PhyloCTMC‘ model has been created, we can attach our sequence
data to the tip nodes in the tree.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq.clamp(data)
</code></pre></div></div>

<p>[Note that although we assume that our sequence data are random
variables—they are realizations of our phylogenetic model—for the
purposes of inference, we assume that the sequence data are “clamped”.]
When this function is called, ‘RevBayes‘ sets each of the stochastic
nodes representing the tips of the tree to the corresponding nucleotide
sequence in the alignment. This essentially tells the program that we
have observed data for the sequences at the tips.</p>

<p>Finally, we wrap the entire model to provide convenient access to the
DAG. To do this, we only need to give the ‘model()‘ function a single
node. With this node, the ‘model()‘ function can find all of the other
nodes by following the arrows in the graphical model:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(Q)
</code></pre></div></div>

<p>Now we have specified a simple phylogenetic analysis—each parameter of
the model will be estimated from every site in our alignment. If we
inspect the contents of ‘mymodel‘ we can review all of the nodes in the
DAG:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel
</code></pre></div></div>

<h2 id="performing-an-mcmc-analysis-under-the-jukes-cantor-model">Performing an MCMC Analysis Under the Jukes-Cantor Model</h2>

<p>In this section, will describe how to set up the MCMC sampler and
summarize the resulting posterior distribution of trees.</p>

<h3 id="specifying-monitors">Specifying Monitors</h3>

<p>For our MCMC analysis, we need to set up a vector of <em>monitors</em> to
record the states of our Markov chain. The monitor functions are all
called ‘mn*‘, where ‘*‘ is the wildcard representing the monitor type.
First, we will initialize the model monitor using the ‘mnModel‘
function. This creates a new monitor variable that will output the
states for all model parameters when passed into a MCMC function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[mni++] = mnModel(filename="output/primates_cytb_JC.log", printgen=10)
</code></pre></div></div>

<p>The ‘mnFile‘ monitor will record the states for only the parameters
passed in as arguments. We use this monitor to specify the output for
our sampled trees and branch lengths.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[mni++] = mnFile(filename="output/primates_cytb_JC.trees", printgen=10, psi)
</code></pre></div></div>

<p>Finally, create a screen monitor that will report the states of
specified variables to the screen with ‘mnScreen‘:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[mni++] = mnScreen(printgen=1000, TL)
</code></pre></div></div>

<p>This monitor mostly helps us to see the progress of the MCMC run.</p>

<h3 id="initializing-and-running-the-mcmc-simulation">Initializing and Running the MCMC Simulation</h3>

<p>With a fully specified model, a set of monitors, and a set of moves, we
can now set up the MCMC algorithm that will sample parameter values in
proportion to their posterior probability. The ‘mcmc()‘ function will
create our MCMC object:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves)
</code></pre></div></div>

<p>Notice that we also specified ‘nruns=2‘ which means that ‘RevBayes‘ will
automatically run 2 independent MCMC runs. You will find that the output
is created in two files with extension ‘_run_1‘ and ‘_run_2‘ for
each replicate and additionally the samples from both runs are combined
into one file for more convenient post-processing. We may wish to run
the ‘.burnin()‘ member function. Recall that this function <strong>does not</strong>
specify the number of states that we wish to discard from the MCMC
analysis as burnin (i.e., the samples collected before the chain
converges to the stationary distribution). Instead, the ‘.burnin()‘
function specifies a <em>completely separate</em> preliminary MCMC analysis
that is used to tune the scale of the moves to improve mixing of the
MCMC analysis.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.burnin(generations=10000,tuningInterval=200)
</code></pre></div></div>

<p>Now, run the MCMC:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=30000)
</code></pre></div></div>

<p>When the analysis is complete, you will have the monitored files in your
output directory.</p>

<p>Methods for visualizing the marginal densities of parameter values are
not currently available in ‘RevBayes‘ itself. Thus, it is important to
use programs like <code class="highlighter-rouge">Tracer</code><a href="#Rambaut2011">(Rambaut and Drummond 2011)</a> to evaluate mixing
and non-convergence.</p>

<p>\
Look at the file called ‘output/primates_cytb_JC.log‘ in
<code class="highlighter-rouge">Tracer</code>. There you see the posterior distribution of the
continuous parameters, <em>e.g.,</em>the tree length
variable ‘TL‘.</p>

<p><img src="figures/primates_cytb_JC_TL_Trace.png" alt="" /> <img src="figures/primates_cytb_JC_TL_Distribution.png" alt="" /></p>
<blockquote>
  <p>Left: Trace of
tree-length samples for one MCMC run. The caterpillar-like look is a
good sign.You will also see that the effective sample size is comparably
large, <em>i.e.,</em>much larger than 200.Right:
Posterior distribution of the tree length of the primate phylogeny under
a Jukes-Cantor substitution model.</p>
</blockquote>

<h2 class="subsection" id="exercise-1">Exercise 1</h2>

<p>We are interested in the phylogenetic relationship of the Tarsiers.
Therefore, we need to summarize the trees sampled from the posterior
distribution. ‘RevBayes‘ can summarize the sampled trees by reading in
the tree-trace file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>treetrace = readTreeTrace("output/primates_cytb_JC.trees", treetype="non-clock")
</code></pre></div></div>

<p>The ‘mapTree()‘ function will summarize the tree samples and write the
maximum <em>a posteriori</em> tree to file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>map_tree = mapTree(treetrace,"output/primates_cytb_JC_MAP.tree")
</code></pre></div></div>

<p><img src="figures/primates_cytb_JC_tree.png" alt="" /></p>
<blockquote>
  <p>Maximum a posteriori
estimate of the primate phylogeny under a Jukes-Cantor substitution
model. The numbers at the nodes show the posterior probabilities for the
clades.We have rooted the tree at the outgroup <em>Galeopterus_variegatus</em></p>
</blockquote>

<p>\
Look at the file called ‘output/primates_cytb_JC_MAP.tree‘ in
<code class="highlighter-rouge">FigTree</code>. We show it in Figure [fig:jc_tree].</p>

<p>Fill in the following table as you go through the tutorial.</p>

<p>Note, you can query the posterior probability of a clade being
monophyletic using the following command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lemuroidea &lt;- clade("Cheirogaleus_major", 
                    "Daubentonia_madagascariensis", 
                    "Lemur_catta", 
                    "Lepilemur_hubbardorum",
                    "Microcebus_murinus",
                    "Propithecus_coquereli",
                    "Varecia_variegata_variegata")
                    
treetrace.cladeProbability( Lemuroidea )
</code></pre></div></div>

<p>[tab:pp]</p>

<dl>
  <dt><strong>Species</strong>                    <strong>Family</strong>         <strong>Parvorder</strong>       <strong>Suborder</strong></dt>
  <dt>  —————————— —————— ——————- —————</dt>
  <dt>  Aotus trivirgatus              Aotidae            Platyrrhini (NWM)   Haplorrhini</dt>
  <dt>  Callicebus donacophilus        Pitheciidae        Platyrrhini (NWM)   Haplorrhini</dt>
  <dt>  Cebus albifrons                Cebidae            Platyrrhini (NWM)   Haplorrhini</dt>
  <dt>  Cheirogaleus major             Cheirogaleidae     Lemuroidea          Strepsirrhini</dt>
  <dt>  Chlorocebus aethiops           Cercopithecoidea   Catarrhini          Haplorrhini</dt>
  <dt>  Colobus guereza                Cercopithecoidea   Catarrhini          Haplorrhini</dt>
  <dt>  Daubentonia madagascariensis   Daubentoniidae     Lemuroidea          Strepsirrhini</dt>
  <dt>  Galago senegalensis            Galagidae          Lorisidae           Strepsirrhini</dt>
  <dt>  Hylobates lar                  Hylobatidea        Catarrhini          Haplorrhini</dt>
  <dt>  Lemur catta                    Lemuridae          Lemuroidea          Strepsirrhini</dt>
  <dt>  Lepilemur hubbardorum          Lepilemuridae      Lemuroidea          Strepsirrhini</dt>
  <dt>  Loris tardigradus              Lorisidae          Lorisidae           Strepsirrhini</dt>
  <dt>  Macaca mulatta                 Cercopithecoidea   Catarrhini          Haplorrhini</dt>
  <dt>  Microcebus murinus             Cheirogaleidae     Lemuroidea          Strepsirrhini</dt>
  <dt>  Nycticebus coucang             Lorisidae          Lorisidae           Strepsirrhini</dt>
  <dt>  Otolemur crassicaudatus        Galagidae          Lorisidae           Strepsirrhini</dt>
  <dt>  Pan paniscus                   Hominoidea         Catarrhini          Haplorrhini</dt>
  <dt>  Perodicticus potto             Lorisidae          Lorisidae           Strepsirrhini</dt>
  <dt>  Propithecus coquereli          Indriidae          Lemuroidea          Strepsirrhini</dt>
  <dt>  Saimiri sciureus               Cebidae            Platyrrhini (NWM)   Haplorrhini</dt>
  <dt>  Tarsius syrichta               Tarsiidae                              Haplorrhini</dt>
  <dt>  Varecia variegata variegata    Lemuridae          Lemuroidea          Strepsirrhini</dt>
  <dd>
    <p>Primate species and famaly relationships.</p>
  </dd>
</dl>

<p>[tab:primates]</p>

<h1 class="section" id="the-hasegawa-kishino-yano-hky-1985-substitution-model">The Hasegawa-Kishino-Yano (HKY) 1985 Substitution Model</h1>

<p>The Jukes-Cantor model assumes that all substitution rates are equal,
which also implies that the stationary frequencies of the four
nucleotide bases are equal. These assumptions are not very biologically
reasonable, so we might wish to consider a more realistic substitution
model that relaxes some of these assumptions. For example, we might
allow stationary frequencies, $\pi$, to be unequal, and allow rates of
transition and transversion substitutions to differ, $\kappa$. This
corresponds to the substitution model proposed by @Hasegawa1985 [HKY],
which is specified with the following instantaneous-rate matrix:</p>

<script type="math/tex; mode=display">% <![CDATA[
Q_{HKY} = \begin{pmatrix} 
{\cdot} 			& {\pi_C} 	& {\kappa\pi_G} 			& {\pi_T} \\ 
{\pi_A} 		& {\cdot} 			& {\pi_C} 			& {\kappa\pi_T} \\ 
{\kappa\pi_A} 			& {\pi_C} 			& {\cdot} 			& {\pi_T} \\ 
{\pi_A} 			& {\kappa\pi_C} 			& {\pi_G} 	& {\cdot}  
\end{pmatrix} \mbox{  .} %]]></script>

<p>[The diagonal ${\cdot}$ entries are equal to the negative sum of the
elements in the corresponding row.]</p>

<p>\
Use the file ‘mcmc_JC.Rev‘ as a starting point for the HKY analysis.</p>

<p>Note that we are adding two new variables to our model. We can define a
variable ‘pi‘ for the stationary frequencies that are drawn from a flat
Dirichlet distribution by</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi_prior &lt;- v(1,1,1,1) 
pi ~ dnDirichlet(pi_prior)
</code></pre></div></div>

<p>Since ‘pi‘ is a stochastic variable, we need to specify a move to
propose updates to it. A good move on variables drawn from a Dirichlet
distribution is the ‘mvBetaSimplex‘. This move randomly takes an element
from the simplex, proposes a new value for it drawn from a Beta
distribution, and then rescales all values of the simplex to sum to 1
again.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvBetaSimplex(pi, weight=2)
moves[mvi++] = mvDirichletSimplex(pi, weight=1)
</code></pre></div></div>

<p>The second new variable is $\kappa$, which specifies the ratio of
transition-transversion rates. The $\kappa$ parameter must be a
positive-real number and a natural choice as the prior distribution is
the lognormal distribution:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kappa ~ dnLognormal(0.0, 1.0)
</code></pre></div></div>

<p>Again, we need to specify a move for this new stochastic variable. A
simple scaling move should do the job.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvScale(kappa)
</code></pre></div></div>

<p>Finally, we need to create the HKY instantaneous-rate matrix using the
‘fnHKY‘ function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnHKY(kappa,pi)
</code></pre></div></div>

<p>This should be all for the HKY model.</p>

<p>\
Don’t forget to change the output file names, otherwise your old
analyses files will be overwritten.</p>

<h2 class="subsection" id="exercise-2">Exercise 2</h2>

<ul>
  <li>
    <p>With figure [fig:jc] as your guide, draw the probabilistic
graphical model of the HKY model.</p>
  </li>
  <li>
    <p>Copy the file called ‘mcmc_JC.Rev‘ and modify it by including the
necessary parameters to specify the HKY substitution model.</p>
  </li>
  <li>
    <p>Run an MCMC analysis to estimate the posterior distribution under
the HKY substitution model.</p>
  </li>
  <li>
    <p>Are the resulting estimates of the base frequencies equal? If not,
how much do they differ? Are the estimated base frequencies similar
to the empirical base frequencies? The empirical base frequencies
are the frequencies of the characters in the alignment, which can be
computed with ‘RevBayes‘ by ‘data.getEmpiricalBaseFrequencies()‘.</p>
  </li>
  <li>
    <p>Is the inferred rate of transition substitutions higher than the
rate of transversion substitutions? If so, by how much?</p>
  </li>
  <li>
    <p>Like the HKY model, the Felsenstein 1981 (F81) substitution model
has unequal stationary frequencies, but it assumes equal
transition-transversion rates <a href="#Felsenstein1981">(Felsenstein 1981)</a>. Can you set up the
F81 model and run an analysis?</p>
  </li>
  <li>
    <p>Complete the Table [tab:pp] by reporting the posterior
probabilities of phylogenetic relationships.</p>
  </li>
</ul>

<h1 class="section" id="the-general-time-reversible-gtr-substitution-model">The General Time-Reversible (GTR) Substitution Model</h1>

<p>The HKY substitution model can accommodate unequal base frequencies and
different rates of transition and transversion substitutions. Despite
these extensions, the HKY model may still be too simplistic for many
real datasets. Here, we extend the HKY model to specify the General Time
Reversible (GTR) substitution model <a href="#Tavare1986">(Tavaré 1986)</a>, which allows all six
exchangeability rates to differ (Figure [fig:gtr]).</p>

<p>The instantaneous-rate matrix for the GTR substitution model is:</p>

<script type="math/tex; mode=display">% <![CDATA[
\resizebox{4in}{!}{$Q_{GTR} = \begin{pmatrix}
{\cdot}	   & {r_{AC}\pi_C} & {r_{AG}\pi_G} & {r_{AT}\pi_T} \\
{r_{AC}\pi_A} & {\cdot}       & {r_{CG}\pi_G} & {r_{CT}\pi_T} \\
{r_{AC}\pi_A} & {r_{CG}\pi_C} & {\cdot}       & {r_{GT}\pi_T} \\
{r_{AC}\pi_A} & {r_{CT}\pi_C} & {r_{GT}\pi_G} & {\cdot}       \\
\end{pmatrix} \mbox{  ,} $} %]]></script>

<p>where the six exchangeability parameters, $r_{ij}$, specify the relative
rates of change between states $i$ and $j$.</p>

<p><img src="figures/gtr_graphical_model.png" alt="" /></p>
<blockquote>
  <p>Graphical model
representation of the General Time Reversible (GTR) phylogenetic model.</p>
</blockquote>

<p>The GTR model requires that we define and specify a prior on the six
exchangeability rates, which we will describe using a flat Dirichlet
distribution. As we did previously for the Dirichlet prior on base
frequencies, we first define a constant node specifying the vector of
concentration-parameter values using the ‘v()‘ function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>er_prior &lt;- v(1,1,1,1,1,1) 
</code></pre></div></div>

<p>This node defines the concentration-parameter values of the Dirichlet
prior distribution on the exchangeability rates. Now, we can create a
stochastic node for the exchangeability rates using the ‘dnDirichlet()‘
function, which takes the vector of concentration-parameter values as an
argument and the ‘‘ operator. Together, these create a stochastic node
named ‘er‘ ($\theta$ in Figure [fig:gtr]):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>er ~ dnDirichlet(er_prior)
</code></pre></div></div>

<p>The Dirichlet distribution assigns probability densities to a group of
parameters: e.g., those that measure proportions and must sum to 1.
Here, we have specified a six-parameter Dirichlet prior, where each
value describes one of the six relative rates of the GTR model: (1)
$A\leftrightarrows C$; (2) $A\leftrightarrows G$; (3)
$A\leftrightarrows T$; (4) $C\leftrightarrows G$; (5)
$C\leftrightarrows T$; (6) $G\leftrightarrows T$. The input parameters
of a Dirichlet distribution are called shape (or concentration)
parameters. The expectation and variance for each variable are related
to the sum of the shape parameters. The prior we specified above is a
‘flat’ or symmetric Dirichlet distribution; all of the shape parameters
are equal (1,1,1,1,1,1). This describes a model that allows for equal
rates of change between nucleotides, such that the expected rate for
each is equal to $\frac{1}{6}$ (Figure [dirichletFig]a). We might also
parameterize the Dirichlet distribution such that all of the shape
parameters were equal to 100, which would also specify a prior with an
expectation of equal exchangeability rates (Figure [dirichletFig]b).
However, by increasing the values of the shape parameters, ‘er_prior
&lt;- v(100,100,100,100,100,100)‘, the Dirichlet distribution will more
strongly favor equal exchangeability rates; (<em>i.e.</em>, a
relatively <em>informative</em> prior). Alternatively, we might
consider an asymmetric Dirichlet parameterization that could reflect a
strong prior belief that transition and transversion substitutions occur
at different rates. For example, we might specify the prior density
‘er_prior &lt;- v(4,8,4,4,8,4)‘. Under this model, the expected rate
for transversions would be $\frac{4}{32}$ and that for transitions would
be $\frac{8}{32}$, and there would be greater prior probability on sets
of GTR rates that matched this configuration (Figure [dirichletFig]c).
Yet another aymmetric prior could specify that each of the six GTR rates
had a different value conforming to a Dirichlet(2,4,6,8,10,12). This
would lead to a different prior probability density for each rate
parameter (Figure [dirichletFig]d). Without strong prior knowledge
about the pattern of relative rates, however, we can better reflect our
uncertainty by using a vague prior on the GTR rates. Notably, all
patterns of relative rates have the same probability density under
‘er_prior &lt;- v(1,1,1,1,1,1)‘.</p>

<p><img src="figures/dirichlet_rates.png" alt="" /></p>
<blockquote>
  <p>Four different examples of
Dirichlet priors on exchangeability rates.</p>
</blockquote>

<p>For each stochastic node in our model, we must also specify a proposal
mechanism if we wish to estimate that parameter. The Dirichlet prior on
our parameter ‘er‘ creates a
<a href="http://en.wikipedia.org/wiki/Simplex"><em>simplex</em></a> of values that sum to
1.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvBetaSimplex(er, weight=3)
moves[mvi++] = mvDirichletSimplex(er, weight=1)
</code></pre></div></div>

<p>We can use the same type of distribution as a prior on the 4 stationary
frequencies ($\pi_A, \pi_C, \pi_G, \pi_T$) since these parameters also
represent proportions. Specify a flat Dirichlet prior density on the
base frequencies:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi_prior &lt;- v(1,1,1,1) 
pi ~ dnDirichlet(pi_prior)
</code></pre></div></div>

<p>The node ‘pi‘ represents the $\pi$ node in Figure [fig:gtr]. Now add
the simplex scale move on the stationary frequencies to the moves
vector:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvBetaSimplex(pi, weight=2)
moves[mvi++] = mvDirichletSimplex(pi, weight=1)
</code></pre></div></div>

<p>We can finish setting up this part of the model by creating a
deterministic node for the GTR instantaneous-rate matrix ‘Q‘. The
‘fnGTR()‘ function takes a set of exchangeability rates and a set of
base frequencies to compute the instantaneous-rate matrix used when
calculating the likelihood of our model.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q := fnGTR(er,pi)
</code></pre></div></div>

<h2 class="subsection" id="exercise-3">Exercise 3</h2>

<ul>
  <li>
    <p>Use one of your previous analysis files—either the ‘mcmc_JC.Rev‘ or
‘HKY.Rev‘—to specify a GTR analysis in a new file called
‘mcmc_GTR.Rev‘. Adapt the old analysis to be performed under the
GTR substitution model.</p>
  </li>
  <li>
    <p>Run an MCMC analysis to estimate the posterior distribution.</p>
  </li>
  <li>
    <p>Complete the table of the phylogenetic relationship of primates.</p>
  </li>
</ul>

<h1 class="section" id="the-discrete-gamma-model-of-among-site-rate-variation">The Discrete Gamma Model of Among Site Rate Variation</h1>

<p>Members of the GTR family of substitution models assume that rates are
homogeneous across sites, an assumption that is often violated by real
data. We can accommodate variation in substitution rate among sites
(ASRV) by adopting the discrete-gamma model <a href="#Yang1994a">(Yang 1994)</a>. This model
assumes that the substitution rate at each site is a random variable
that is described by a discretized gamma distribution, which has two
parameters: the shape parameter, $\alpha$, and the rate parameter,
$\beta$. In order that we can interpret the branch lengths as the
expected number of substitutions per site, this model assumes that the
mean site rate is equal to 1. The mean of the gamma is equal to
$\alpha/\beta$, so a mean-one gamma is specified by setting the two
parameters to be equal, $\alpha=\beta$. This means that we can fully
describe the gamma distribution with the single shape parameter,
$\alpha$. The degree of among-site substitution rate variation is
inversely proportional to the value of the $\alpha$-shape parameter. As
the value of the $\alpha$-shape increases, the gamma distribution
increasingly resembles a normal distribution with decreasing variance,
which therefore corresponds to decreasing levels of ASRV (Figure
[asrhGammaFig]). By contrast, when the value of the $\alpha$-shape
parameter is $&lt; 1$, the gamma distribution assumes a concave
distribution that concentrates most of the prior density on low rates,
but retains some prior mass on sites with very high rates, which
therefore corresponds to high levels of ASRV (Figure [asrhGammaFig]).
Note that, when $\alpha = 1$, the gamma distribution collapses to an
exponential distribution with a rate parameter equal to $\beta$.</p>

<p><img src="figures/asrh_gamma.png" alt="" /></p>
<blockquote>
  <p>The probability density of
mean-one gamma-distributed rates for different values of the
$\alpha$-shape parameter.</p>
</blockquote>

<p>We typically lack prior knowledge regarding the degree of ASRV for a
given alignment. Accordingly, rather than specifying a precise value of
$\alpha$, we can instead estimate the value of the $\alpha$-shape
parameter from the data. This requires that we specify a diffuse
(relatively ‘uninformative’) prior on the $\alpha$-shape parameter. For
this analysis, we will use a lognormal distribution with a mean
parameter, ‘alpha_prior_mean‘, equal to ‘5.0‘, and standard deviation,
‘alpha_prior_sd‘, equal to 0.587405 (thus, 95% of the prior density
spans exactly one order of magnitude).</p>

<p>This approach for accommodating ASRV is another example of a
hierarchical model (Figure [fig:gtrg]). That is, variation in
substitution rates across sites is addressed by applying a site-specific
rate multiplier to each of the $j$ sites, $r_j$. These rate-multipliers
are drawn from a discrete, mean-one gamma distribution; the shape of
this prior distribution (and the corresponding degree of ASRV) is
governed by the $\alpha$-shape parameter. The $\alpha$-shape parameter,
in turn, is treated as a lognormal distributed random variable. Finally,
the shape of the lognormal prior is governed by the mean and standard
deviation parameters, which are set to fixed values.</p>

<p><img src="figures/gtrg_graphical_model.png" alt="" /></p>
<blockquote>
  <p>Graphical model
representation of the General Time Reversible (GTR) + Gamma phylogenetic
model with invariable sites.</p>
</blockquote>

<h2 id="setting-up-the-gamma-model-in-revbayes">Setting up the Gamma Model in ‘RevBayes‘</h2>

<p>Create a constant node called ‘alpha_prior_mean‘ for the mean
parameter and a constant node called ‘alpha_prior_sd‘ for the standard
deviation of the lognormal prior on the gamma-shape parameter (this is
represented as the constant $m_\alpha$ and $sd_\alpha$ parameters in
Figure [fig:gtrg]):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha_prior_mean &lt;- ln(5.0)
alpha_prior_sd &lt;- 0.587405
</code></pre></div></div>

<p>Then create a stochastic node called ‘alpha‘ with a lognormal prior
(this represents the stochastic node for the $\alpha$-shape parameter in
Figure [fig:gtrg]):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha ~ dnLognormal( alpha_prior_mean, alpha_prior_sd )
</code></pre></div></div>

<p>The way the ASRV model is implemented involves discretizing the mean-one
gamma distribution into a set number of rate categories, $k$. Thus, we
can analytically marginalize over the uncertainty in the rate at each
site. The likelihood of each site is averaged over the $k$ rate
categories, where the rate multiplier is the mean (or median) of each of
the discrete $k$ categories. To specify this, we need a deterministic
node that is a vector that will hold the set of $k$ rates drawn from the
gamma distribution with $k$ rate categories. The ‘fnDiscretizeGamma()‘
function returns this deterministic node and takes three arguments: the
shape and rate of the gamma distribution and the number of categories.
Since we want to discretize a mean-one gamma distribution, we can pass
in ‘alpha‘ for both the shape and rate.</p>

<p>Initialize the ‘gamma_rates‘ deterministic node vector using the
‘fnDiscretizeGamma()‘ function with ‘4‘ bins:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gamma_rates := fnDiscretizeGamma( alpha, alpha, 4 )
</code></pre></div></div>

<p>Note that here, by convention, we set $k = 4$. The random variable that
controls the rate variation is the stochastic node ‘alpha‘. We will
apply a simple scale move to this parameter.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvScale(alpha, weight=2.0)
</code></pre></div></div>

<p>Remember that you need to call the ‘PhyloCTMC‘ constructor to include
the new site-rate parameter:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC(tree=psi, Q=Q, siteRates=gamma_rates, type="DNA")
</code></pre></div></div>

<h2 class="subsection" id="exercise-4">Exercise 4</h2>

<p>Modify the previous GTR analysis to specify the GTR+Gamma model. Run an
MCMC simulation to estimate the posterior distribution.</p>

<ul>
  <li>
    <p>Is there an impact on the estimated phylogeny compared with the
previous analyses? Look at the MAP tree and the posterior
probabilities of the clades.</p>
  </li>
  <li>
    <p>Complete the table of the phylogenetic relationship of primates.</p>
  </li>
</ul>

<h1 class="section" id="modeling-invariable-sites">Modeling Invariable Sites</h1>

<p>All of the substitution models described so far assume that the sequence
data are potentially variable. That is, we assume that the sequence data
are random variables; specifically, we assume that they are realizations
of the specified ‘PhyloCTMC‘ distribution. However, some sites may not
be free to vary—when the substitution rate of a site is zero, it is said
to be <em>invariable</em>. Invariable sites are often confused with <em>invariant</em>
sites—when each species exhibits the same state, it is said to be
invariant. The concepts are related but distinct. If a site is truly
invariable, it will necessarily give rise to an invariant site pattern,
as such sites will always have a zero substitution rate. However, an
invariant site pattern may be achieved via multiple substitutions that
happen to end in the same state for every species.</p>

<p>Here we describe an extension to our phylogenetic model to accommodate
invariable sites. Under the invariable-sites model <a href="#Hasegawa1985">(Hasegawa et al. 1985)</a>, each
site is invariable with probability ‘pinvar‘, and variable with
probability $1-$‘pinvar‘.</p>

<p>First, let’s have a look at the data and see how many invariant sites we
have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data.getNumInvariantSites()
</code></pre></div></div>

<p>There seem to be a substantial number of invariant sites.</p>

<p>Now let’s specify the invariable-sites model in ‘RevBayes‘. We need to
specify the prior probability that a site is invariable. A Beta
distribution is a common choice for parameters representing
probabilities.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pinvar ~ dnBeta(1,1)
</code></pre></div></div>

<p>The ‘Beta(1,1)‘ distribution is a flat prior distribution that specifies
equal probability for all values between 0 and 1.</p>

<p>Then, as usual, we add a move to change this stochastic variable; we’ll
used a simple sliding window move.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvSlide(pinvar)
</code></pre></div></div>

<p>Finally, you need to call the ‘PhyloCTMC‘ constructor to include the
new‘pinvar‘ parameter:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC(tree=psi, Q=Q, siteRates=gamma_rates, pInv=pinvar, type="DNA")
</code></pre></div></div>

<h2 class="subsection" id="exercise-5">Exercise 5</h2>

<ul>
  <li>
    <p>Extend the GTR model to account for invariable sites and run
an analysis.</p>
  </li>
  <li>
    <p>What is the estimated probability of invariable sites and how does
it relate to the ratio of invariant sites to the total number of
sites?</p>
  </li>
  <li>
    <p>Extend the GTR+$\Gamma$ model to account for invariable sites and
run an analysis.</p>
  </li>
  <li>
    <p>What is the estimated probability of invariable sites now?</p>
  </li>
  <li>
    <p>Complete the table of the phylogenetic relationship of primates.</p>
  </li>
</ul>

<p>Version dated:</p>


      <ol class="bibliography"><li><span id="Hoehna2017a">Höhna S., Landis M.J., Heath T.A. 2017. Phylogenetic Inference using RevBayes. Current Protocols in Bioinformatics.</span>

<a href="https://doi.org/10.1002/cpbi.22">10.1002/cpbi.22</a>

</li>
<li><span id="Jukes1969">Jukes T.H., Cantor C.R. 1969. Evolution of Protein Molecules. Mammalian Protein Metabolism. 3:21–132.</span>

<a href="https://doi.org/10.1016/B978-1-4832-3211-9.50009-7">10.1016/B978-1-4832-3211-9.50009-7</a>

</li>
<li><span id="Zhang2012">Zhang C., Rannala B., Yang Z. 2012. Robustness of Compound Dirichlet Priors for Bayesian Inference of Branch Lengths. Systematic Biology. 61:779–784.</span>

</li>
<li><span id="Rambaut2011">Rambaut A., Drummond A.J. 2011. Tracer v1.5. .</span>


<a href="http://tree.bio.ed.ac.uk/software/tracer/">http://tree.bio.ed.ac.uk/software/tracer/</a>
</li>
<li><span id="Felsenstein1981">Felsenstein J. 1981. Evolutionary Trees from DNA Sequences: a Maximum Likelihood Approach. Journal of Molecular Evolution. 17:368–376.</span>

<a href="https://doi.org/10.1007/BF01734359">10.1007/BF01734359</a>

</li>
<li><span id="Tavare1986">Tavaré S. 1986. Some Probabilistic and Statistical Problems in the Analysis of DNA Sequences. Some Mathematical Questions in Biology: DNA Sequence Analysis. 17:57–86.</span>

</li>
<li><span id="Yang1994a">Yang Z. 1994. Maximum Likelihood Phylogenetic Estimation from DNA Sequences with Variable Rates Over Sites: Approximate Methods. Journal of Molecular Evolution. 39:306–314.</span>

<a href="https://doi.org/10.1007/BF00160154">10.1007/BF00160154</a>

</li>
<li><span id="Hasegawa1985">Hasegawa M., Kishino H., Yano T. 1985. Dating of the Human-Ape Splitting by a molecular Clock of Mitochondrial DNA. Journal of Molecular Evolution. 22:160–174.</span>

<a href="https://doi.org/10.1007/BF02101694">10.1007/BF02101694</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2>References</h2>"+elem_ol.outerHTML
	}
}
</script>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/revbayes_tutorials/license">License</a> | <a href="/revbayes_tutorials/citation">Cite RevBayes</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users' Forum</a>
    </div>
  </div>
  </div>
</footer>

    </div>
    <script src="/revbayes_tutorials/assets/js/vendor/jquery.min.js"></script>
<script src="/revbayes_tutorials/assets/js/vendor/FileSaver.min.js"></script>
<script src="/revbayes_tutorials/assets/js/vendor/jszip.min.js"></script>
<script src="/revbayes_tutorials/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(".highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge")
    this.classList = "Rev highlighter-rouge";
  
});
</script>

<script src="/revbayes_tutorials/assets/js/base.js"></script>

<script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

  </body>
</html>
