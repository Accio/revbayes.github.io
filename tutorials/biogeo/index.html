<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="search-domain" value="https://revbayes.github.io/revbayes-site/">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
    <link rel="stylesheet" href="/revbayes-site/assets/css/syntax.css">
    <link rel="stylesheet" type="text/css" href="/revbayes-site/assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="/revbayes-site/assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="/revbayes-site/assets/css/main.css" />
    <title>RevBayes: Phylogenetic Inference using RevBayes</title>
  </head>
  <body>
    <div class="container">
      <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a href="https://revbayes.github.io" class="pull-left">
        <img class="navbar-logo" src="/revbayes-site/assets/img/aquabayes-desaturated.png" alt="RevBayes Logo" />
      </a>
      
      <a class="navbar-brand" href="/revbayes-site/">Home</a>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/revbayes-site/software/">Software</a></li>
        <li><a href="/revbayes-site/developer/">Developer</a></li>
        <li><a href="/revbayes-site/tutorials/">Tutorials</a></li>
        <li><a href="/revbayes-site/workshops/">Workshops</a></li>
      </ul>
      <!-- <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form> -->
    </div>
  </div>
</nav>

      <div class="row">
	<h1 class="maintitle">Phylogenetic Inference using RevBayes</h1>
	<h3 class="subtitle">Historical biogeography</h3>
	<h4 class="maintitle">Michael J. Landis</h4>
</div>

      
<blockquote class="overview no-print" id="overview">
  <h2>Overview</h2>
  <div class="row">
    <div class="col-md-9">
        <strong>Prerequisites</strong>
        
          <ul id="prerequisites">
          
            
            
            <li><a href="/revbayes-site/tutorials/intro/">Statistical Inference Using RevBayes</a></li>
          
          </ul>
        
    </div>
  </div>
</blockquote>

<blockquote class="tutorial_files no-print" id="tutorial_files">
  <h2>Data files and scripts</h2>
  
    <div class="row" id="script_row">
      <div class="col-md-9">
          <strong>Scripts</strong>
          <ul id="scripts"></ul>
        </div>
    </div>
</blockquote>
      <h2 id="introduction-introduction-unnumbered">Introduction {#introduction .unnumbered}</h2>

<p>Many fundamental evolutionary processes, such as adaptation, speciation,
and extinction, operate in a spatial context. When the historical aspect
of this spatial context cannot be observed directly, as is often the
case, biogeographic inference may be applied to estimate ancestral
species ranges. This works by leveraging phylogenetic, molecular, and
geographical information to model species distributions as the outcome
of biogeographic processes. How to best model these processes requires
special consideration, such as how ranges are inherited following
speciation events, how geological events might influence dispersal
rates, and what factors affect rates of dispersal and extirpation. A
major technical challenge of modeling range evolution is how to
translate these natural processes into stochastic processes that remain
tractable for inference. This tutorial provides a brief background in
some of these models, then describes how to perform Bayesian inference
of historical biogeography using RevBayes.</p>

<h2 id="contents-contents-unnumbered">Contents {#contents .unnumbered}</h2>

<p>The Historical Biogeography guide contains several tutorials</p>

<ul>
  <li>
    <p>Section [sec:bg_intro2]: Overview of the
Dispersal-Extinction-Cladogenesis (DEC) process</p>
  </li>
  <li>
    <p>Section [sec:bg_simple]: A simple DEC analysis</p>
  </li>
  <li>
    <p>Section [sec:bg_epoch]: An improved DEC analysis</p>
  </li>
  <li>
    <p>Section [sec:bg_phylo]: Biogeographic dating using DEC</p>
  </li>
</ul>

<h2 id="recommended-tutorials-recommended-tutorials-unnumbered">Recommended tutorials {#recommended-tutorials .unnumbered}</h2>

<p>The Historical Biogeography tutorials assume the reader is familiar with
the content covered in the following RevBayes tutorials</p>

<ul>
  <li>
    <p><strong>Rev Basics</strong></p>
  </li>
  <li>
    <p><strong>Molecular Models of Character Evolution</strong></p>
  </li>
  <li>
    <p><strong>Running and Diagnosing an MCMC Analysis</strong></p>
  </li>
  <li>
    <p><strong>Divergence Time Estimation and Node Calibrations</strong></p>
  </li>
</ul>

<h1 id="sec:bg_intro2">Overview of the Dispersal-Extinction-Cladogenesis model</h1>

<p>The Dispersal-Extinction-Cladogenesis (DEC) process models range
evolution as a discrete-valued process (missing reference). There are
three key components to understanding the DEC model: range characters,
anagenetic range evolution, and cladogenetic range evolution (Figure
[fig:dec_cartoon]).</p>

<blockquote class="figure">
  <p><img src="figures/fig_range_evol_events.png" alt="" /> 
Cartoon of behavior
of the DEC model.Two anagenetic events (a,b) and five cladogenetic (c–g)
events are shown for a system with two areas.Areas are shaded when
inhabited by a given lineage and left blank when uninhabited.Time
proceeds from left to right.(a) Dispersal: a new area to be added to the
species range.(b) Extirpation (or local extinction): the species range
loses a previously inhabited area.(c) Narrow sympatry: When the
ancestral range contains one area, both daughter lineages inherit that
area.(d) Subset sympatry: When the ancestral range is widespread, one
daughter inherits the ancestral range and the other daughter inherits
only one area.(e) Allopatry (or vicariance): When the ancestral range is
widespread, one daughter lineage a subset of the ancestral areas while
the other daughter inherits all remaining ancestral areas.(f) Widespread
sympatry: When the ancestral range is widespread, both daughters inherit
the ancestral range.(g) Jump dispersal (or founder speciation): One
daughter inherits the ancestral range while the other daughter inherits
a new unoccupied area.</p>
</blockquote>

<h2 id="discrete-range-characters">Discrete range characters</h2>

<p>DEC interprets taxon ranges as presence-absence data, that is, where a
species is observed or not observed across multiple discrete areas. For
example, say there are three areas, A, B, and C. If a species is present
in areas A and C, then its range equals AC, which can also be encoded
into the length-3 bit vector, 101. Bit vectors may also be transformed
into (decimal) integers, <em>e.g.,</em>the binary
number 101 equals the decimal number 5.</p>

<dl>
  <dt>Range           Bits  Size   State</dt>
  <dt>  ————- —— —— ——-</dt>
  <dt>  $\emptyset$      000   0       0</dt>
  <dt>  A                100   1       1</dt>
  <dt>  B                010   1       2</dt>
  <dt>  C                001   1       3</dt>
  <dt>  AB               110   2       4</dt>
  <dt>  AC               101   2       5</dt>
  <dt>  BC               011   2       6</dt>
  <dt>  ABC              111   3       7</dt>
  <dd>
    <p>Example of discrete range representations for an analysis with areas
  A, B, and C.</p>
  </dd>
</dl>

<p>The decimal representation of range states is rarely used in discussion,
but it is useful to keep in mind when considering the total number of
possible ranges for a species and when processing output.</p>

<h2 id="anagenetic-range-evolution">Anagenetic range evolution</h2>

<p>In the context of the DEC model, anagenesis refers to range evolution
that occurs between speciation events within lineages. There are two
types of anagenetic events, dispersal (Figure [fig:dec_cartoon]a) and
(local) extinction or exitrpation (Figure [fig:dec_cartoon]b).
Because DEC uses discrete-valued ranges, anagenesis is modeled using a
continuous-time Markov chain. This, in turn, allows us to compute
transition probability of a character changing from $i$ to $j$ in time
$t$ through matrix exponentiation
<script type="math/tex">\mathbf{P}_{ij}(t) = \left[ \exp \left\lbrace \mathbf{Q}t \right\rbrace \right]_{ij},</script>
where $\textbf{Q}$ is the instantaneous rate matrix defining the rates
of change between all pairs of characters, and $\textbf{P}$ is the
transition probability rate matrix. The indices $i$ and $j$ represent
different ranges, each of which is encoded as the set of areas occupied
by the species. The probability has integrated over all possible
scenarios of character transitions that could occur during $t$ so long
as the chain begins in range $i$ and ends in range $j$. We can then
encode ${\bf Q}$ to reflect the allowable classes of range evolution
events with biologically meaningful parameters. For three areas, the
rates in the anagenetic rate matrix are</p>

<script type="math/tex; mode=display">% <![CDATA[
\textbf{Q} = 
	\begin{array}{c|cccccccc}
		& \emptyset & A & B & C & AB & AC & BC & ABC \\
		\hline
		\emptyset 	& - 	& 0 	& 0 	& 0 		& 0			& 0 		& 0 		& 0 \\
		A 			& e_A 	& - 	& 0 	& 0 		& d_{AB}	& d_{AC} 	& 0 		& 0 \\
		B 			& e_B 	& 0 	& - 	& 0 		& d_{BA}	& 0 		& d_{BC} 	& 0 \\
		C 			& e_C 	& 0 	& 0 	& - 		& 0 		& d_{CA} 	& d_{CB} 	& 0 \\
		AB 			& 0 	& e_A 	& e_B 	& 0 		& -			& 0 		& 0 		& d_{AC} + d_{BC} \\
		AC 			& 0 	& e_C 	& 0 	& e_A 		& 0			& - 		& 0 		& d_{AB} + d_{CB} \\
		BC 			& 0 	& 0 	& e_C 	& e_B 		& 0			& 0 		& - 		& d_{BA} + d_{CA} \\
		ABC 		& 0 	& 0 	& 0 	& 0 		& e_C 		& e_B 		& e_A 		& - \\								
	\end{array} %]]></script>

<p>where $e = ( e_A, e_B, e_C )$ are the (local) extinction rates per area,
and $d = ( d_{AB}, d_{AC}, d_{BC}, d_{BA}, d_{CA}, d_{CB})$ are the
dispersal rates between areas. Notice that the sum of rates leaving the
null range ($\emptyset$) is zero, meaning any lineage that loses all
areas in its range remains that way permanently.</p>

<p>To build our intuition, let’s construct a DEC rate matrix in RevBayes.
Assume you have three areas</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_areas &lt;- 3
</code></pre></div></div>

<p>First, create a matrix of dispersal rates between area pairs, with rates
$d_{AB} = d_{AC} = \ldots = d_{CB} = 1$.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        dr[i][j] &lt;- 1.0
    }
}
</code></pre></div></div>

<p>Next, let’s create the extirpation rates with values $e_A=e_B=e_C=1$</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        er[i][j] &lt;- 0.0
    }
    er[i][i] &lt;- 1.0
}
</code></pre></div></div>

<p>When the extirpation rate matrix is a diagonal matrix (i.e. all
non-diagonal entries are zero), extirpation rates are mutually
independent as in <a href="#Ree2005">(Ree et al. 2005)</a>. More complex models that penalize
widespread ranges that span disconnected areas are explored in later
sections.</p>

<p>To continue, create the DEC rate matrix from the dispersal rates
(dr) and extirpation rates (er).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_DEC := fnDECRateMatrix(dispersalRates=dr, extirpationRates=er)
Q_DEC
</code></pre></div></div>

<div class="console highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [ [ 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000 ] ,
        1.0000, -3.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.0000 ] ,
        1.0000, 0.0000, -3.0000, 0.0000, 1.0000, 0.0000, 1.0000, 0.0000 ] ,
        1.0000, 0.0000, 0.0000, -3.0000, 0.0000, 1.0000, 1.0000, 0.0000 ] ,
        0.0000, 1.0000, 1.0000, 0.0000, -4.0000, 0.0000, 0.0000, 2.0000 ] ,
        0.0000, 1.0000, 0.0000, 1.0000, 0.0000, -4.0000, 0.0000, 2.0000 ] ,
        0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.0000, -4.0000, 2.0000 ] ,
        0.0000, 0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 1.0000, -3.0000 ] ]
</code></pre></div></div>

<p>Compute the anagenetic transition probabilities for a branch of length
0.2.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp_DEC &lt;- Q_DEC.getTransitionProbabilities(rate=0.2)
tp_DEC
</code></pre></div></div>

<div class="console highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [ [ 1.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000],
      [ 0.000, 0.673, 0.013, 0.013, 0.123, 0.123, 0.005, 0.050],
      [ 0.000, 0.013, 0.673, 0.013, 0.123, 0.005, 0.123, 0.050],
      [ 0.000, 0.013, 0.013, 0.673, 0.005, 0.123, 0.123, 0.050],
      [ 0.000, 0.107, 0.107, 0.004, 0.502, 0.031, 0.031, 0.218],
      [ 0.000, 0.107, 0.004, 0.107, 0.031, 0.502, 0.031, 0.218],
      [ 0.000, 0.004, 0.107, 0.107, 0.031, 0.031, 0.502, 0.218],
      [ 0.000, 0.021, 0.021, 0.021, 0.107, 0.107, 0.107, 0.616]]
</code></pre></div></div>

<p>Notice how the structure of the rate matrix is reflected in the
transition probability matrix. For example, ranges that are separated by
multiple dispersal and extirpation events are the most improbable:
transitioning from going from A to BC takes a minimum of three events
and has probability 0.005.</p>

<p>Also note that the probability of entering or leaving the null range is
zero. By default, the RevBayes conditions the anagenetic range
evolution process on never entering the null range when computing the
transition probabilities (nullRange=“CondSurv”). This
allows the model to both simulate and infer using the same transition
probabilities. @Massana2015 first noted that the null range—an
unobserved absorbing state—results in abnormal extirpation rate and
range size estimates. Their proposed solution to eliminate the null
range from the state space is enabled with the
nullRange=“Exclude” setting. The
nullRange=“Include” setting provides no special handling of
the null range, and produces the raw probabilities of @Ree2005.</p>

<h2 id="cladogenetic-range-evolution">Cladogenetic range evolution</h2>

<p>The cladogenetic component of the DEC model describes evolutionary
change accompanying speciation events (Figure [fig:dec_cartoon]c–g).
In the context of range evolution, daughter species do not necessarily
inherit their ancestral range in an identical manner. For each internal
node in the reconstructed tree, one of several cladogenetic events can
occur, some of which are described below.</p>

<p>Beginning with the simplest case first, suppose the range of a species
is $A$ the moment before speciation occurs at an internal phylogenetic
node. Since the species range is size one, both daughter lineages
necessarily inherit the ancestral species range ($A$). In DEC parlance,
this is called a narrow sympatry event (Figure [fig:dec_cartoon]c).
Now, suppose the ancestral range is $ABC$. Under subset sympatry, one
lineage identically inherits the ancestral species range, $ABC$, while
the other lineage inherits only a single area, i.e. only $A$ or $B$ or
$C$ (Figure [fig:dec_cartoon]d). Under allopatric cladogenesis, the
ancestral range is split evenly among daughter lineages, e.g. one
lineage may inherit $AB$ and the other inherits $C$ (Figure
[fig:dec_cartoon]e). For widespread sympatric cladogenesis, both
lineages inherit the ancestral range, $ABC$ (Figure
[fig:dec_cartoon]f). Finally, supposing the ancestral range is $A$,
jump dispersal cladogenesis results in one daughter lineage inheriting
the ancestral range $A$, and the other daughter lineage inheriting a
previously uninhabited area, $B$ or $C$ (Figure [fig:dec_cartoon]g).
See @Matzke2012 for an excellent overview of the cladogenetic state
transitions described in the literature.</p>

<p>Make the cladogenetic probability event matrix</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clado_event_types = [ "s", "a" ]
clado_event_probs &lt;- simplex( 1, 1 )
P_DEC := fnDECCladoProbs(eventProbs=clado_event_probs,
                         eventTypes=clado_event_types,
                         numCharacters=n_areas)
</code></pre></div></div>

<p><code class="highlighter-rouge">clado_event_types</code> defines what cladogenetic event types
are used. “a” and “s” indicate allopatry and
subset sympatry, as described in <a href="#Ree2005">(Ree et al. 2005)</a>. Other cladogenetic events
include jump dispersal [“j”] (missing reference) and full sympatry
[“f”} <a href="#Landis2013a">(Landis et al. 2013)</a>. The cladogenetic event probability
matrix will assume that eventProbs and
eventTypes share the same order.</p>

<p>Print the cladogenetic transition probabilities</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>P_DEC
</code></pre></div></div>

<div class="console highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       [
         ( 1 -&gt; 1, 1 ) = 1.0000,
         ( 2 -&gt; 2, 2 ) = 1.0000,
         ( 3 -&gt; 3, 3 ) = 1.0000,
         ...
         ( 7 -&gt; 7, 1 ) = 0.0833,
         ( 7 -&gt; 7, 2 ) = 0.0833,
         ( 7 -&gt; 7, 3 ) = 0.0833
       ]
</code></pre></div></div>

<p>The cladogenetic probability matrix becomes very sparse for large
numbers of areas, so only non-zero values are shown. Each row reports a
triplet of states—the ancestral state and the two daughter states—with
the probability associated with that event. Since these are proper
probabilities, the sum of probabilities for a given ancestral state over
all possible cladogenetic outcomes equals one.</p>

<h2 id="things-to-consider">Things to consider</h2>

<p>The probabilities of anagenetic change along lineages must account for
all combinations of starting states and ending states. For 3 areas,
there are 8 states, and thus $8 \times 8 = 64$ probability terms for
pairs of states. For cladogenetic change, we need transition
probabilities for all combinations of states before cladogenesis, after
cladogenesis for the left lineage, and after cladogenesis for the right
lineage. Like above, for three areas, there are 8 states, and
$8 \times 8 \times 8 = 512$ cladogenetic probability terms.</p>

<p>Of course, this model can be specified for more than three areas. Let’s
consider what happens to the size of <strong>Q</strong> when the number of areas,
$N$, becomes large. For three areas, <strong>Q</strong> is size $8 \times 8$. For ten
areas, <strong>Q</strong> is size $2^{10} \times 2^{10} = 1024 \times 1024$, which
approaches the largest size matrices that can be exponentiated in a
practical amount of time. For twenty areas, <strong>Q</strong> is size
$2^{20} \times 2^{20} \approx 10^6 \times 10^6$ and exponentiation is
not viable. Thus, selecting the discrete areas for a DEC analysis should
be done with regard to what one hopes to learn through the analysis
itself.</p>

<h2 id="some-questions">Some questions</h2>

<p><strong>For the three-area DEC rate matrix above, what is the rate of
leaving state AC in terms of dispersal and extinction
parameters?</strong></p>

<p><strong>What series of transition events might explain a lineage
evolving from range $ABC$ to range $A$? From range $AB$ to range $C$?
(Hint: more than one event is needed!)</strong></p>

<p><strong>Imagine a DEC rate matrix with four areas, $ABCD$. What would
be the dispersal rate for $Q_{BC,BCD}$? How many states does a DEC rate
matrix with four areas have? What is the relationship between the number
of areas and the number of states under the DEC model?</strong></p>

<p><strong>Given the state is $AB$ before cladogenesis, and allowing
subset sympatry, widespread sympatry, and allopatry, what are the 7
possible states in the daughter lineages after cladogenesis?</strong></p>

<p><strong>For three areas, there are three narrow, four widespread, 18
subset sympatric events, and 12 allopatric cladogenesis events. What
proportion of terms in the cladogenesis matrix are zero?</strong></p>

<h1 id="sec:bg_simple">Simple DEC analysis</h1>

<p>The following series of tutorials will estimate the ancestral ranges of
the silversword alliance (Tribe <em>Madiinae</em>), a young and
diverse clade of about 50 species and subspecies. Although silverswords
are endemic to Hawaii, they are nested within a larger clade alongside
tarweeds, which are native to western continental North America
<a href="#Baldwin1991">(Baldwin et al. 1991)</a>. The size and age of the silversword clade, combined with
our knowledge of Hawaiian island formation, makes it an ideal system to
explore concepts in historical biogeography and phylogeny. For further
reading, consult: @Carlquist1959 <a href="#Baldwin1998">(Baldwin and Sanderson 1998)</a>.</p>

<blockquote>
  <p><img src="figures/fig_hawaii_areas.png" alt="" /> 
A beautiful figure of the
discrete areas for the tutorial. Six areas are shown: Kauai and Niihau
(K); Oahu (O); Maui-Nui, Lanai, and Molokai (M); Hawaii (H); the
remaining Hawaiian islands (R); and the North American mainland (Z).</p>
</blockquote>

<p class="figure">For this tutorial we’ll focus entirely on the silversword alliance and
the modern Hawaiian archipelago. To begin, we’ll use just four areas, K,
O, M, and H, and include areas R and Z in later analyses (Figure
[fig:hawaii_areas]). The species ranges used in this exercise follow
@Gillespie2009.</p>

<dl>
  <dt>Range         Areas    Size   State</dt>
  <dt>  ————- ——- —— ——-</dt>
  <dt>  $\emptyset$   0000      0       0</dt>
  <dt>  K             1000      1       1</dt>
  <dt>  O             0100      1       2</dt>
  <dt>  M             0010      1       3</dt>
  <dt>  H             0001      1       4</dt>
  <dt>  KO            1100      2       5</dt>
  <dt>  KM            1010      2       6</dt>
  <dt>  OM            0110      2       7</dt>
  <dt>  KH            1001      2       8</dt>
  <dt>  OH            0101      2       9</dt>
  <dt>  MH            0011      2      10</dt>
  <dt>  KOM           1110      3      11</dt>
  <dt>  KOH           1101      3      12</dt>
  <dt>  KMH           1011      3      13</dt>
  <dt>  OMH           0111      3      14</dt>
  <dt>  KOMH          1111      4      15</dt>
  <dd>
    <p>Area coding used for four areas: K is Kauai and Nihoa; O is Oahu; M
  is Maui Nui, Lanai, and Molokai; H is Hawaii island.</p>
  </dd>
</dl>

<h2 id="analysis-analysis-unnumbered">Analysis {#analysis .unnumbered}</h2>

<p>First, create file management variables for input and output</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>range_fn = "data/n4/silversword.n4.range.nex"
tree_fn = "data/n4/silversword.tre"
out_fn = "output/simple"
</code></pre></div></div>

<p>then read in our character data as binary presence-absence characters</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dat_range_01 = readDiscreteCharacterData(range_fn)
</code></pre></div></div>

<p>then encode the species ranges into natural numbers</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dat_range_n    = formatDiscreteCharacterData(dat_range_01, "DEC")
</code></pre></div></div>

<p>Record the number of areas (characters) from the discrete character data
object</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_areas = dat_range_01.nchar()
</code></pre></div></div>

<p>You can view the taxon data to see how characters are coded both as
human-readable presence-absence data and as computer-readable natural
numbers</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dat_range_01[1]
</code></pre></div></div>

<div class="console highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      Argyroxiphium_grayanum_East_Maui:
        0010
    dat_range_n[1]
      Argyroxiphium_grayanum_East_Maui:
        3
</code></pre></div></div>

<p>We’ll want to record the relationship between range states and range
labels when producing an ancestral range estimate figure. First, store
the vector of range state descriptions</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>state_desc = dat_range_n.getStateDescriptions()
</code></pre></div></div>

<p>then write it to file</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>state_desc_str = "state,range\n"
for (i in 1:state_desc.size())
{
    state_desc_str += (i-1) + "," + state_desc[i] + "\n"
}
write(state_desc_str, file=out_fn+".state_labels.txt")
</code></pre></div></div>

<p>For this tutorial we’ll assume we know the dated species phylogeny
without error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree &lt;- readTrees(tree_fn)[1]
</code></pre></div></div>

<p>Next, we’ll build the anagenetic rate matrix for the DEC model. In its
simplest form, the rate matrix requires a dispersal rate and an
extirpation rate. For this analysis, we’ll assume that all pairs of
areas share the same dispersal rate and all areas share the same
extirpation rate. To gain greater control to observe and manage prior
sensitivity, we’ll reparameterize the DEC rate matrix to report the
<em>relative</em> rates of dispersal versus extirpation events. In
order for anagenetic event rates to be measured on an absolute time
scale (e.g. in millions of years), we will also introduce a a
biogeographic rate parameter, similar to the molecular clock parameter
used in dating analyses.</p>

<p>First, create a parameter for the arrival rate of anagenetic range
evolution events. We’ll apply an uninformative prior to the rate’s
magnitude by first assigning a uniform distribution to the log$_{10}$
rate.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log10_rate_bg ~ dnUniform(-4,2)
log10_rate_bg.setValue(-2)
moves[1] = mvSlide(log10_rate_bg, weight=4)
</code></pre></div></div>

<p>then convert the rate from log-scale to linear-scale with a
deterministic node</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rate_bg := 10^log10_rate_bg
</code></pre></div></div>

<p>This yields a uniform prior over orders of magnitude, ranging from
$10^{-4}$ to $10^2$ events per million years.</p>

<p>Because the rate matrix will describe the relative anagenetic event
rates, we can safely assume that dispersal occurs at the relative
(fixed) rate of one.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispersal_rate &lt;- 1.0
</code></pre></div></div>

<p>then create the dispersal rate matrix</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_areas) {
  for (j in 1:n_areas) {
    dr[i][j] &lt;- dispersal_rate
  }
}
</code></pre></div></div>

<p>Next, assign a prior distribution to the relative extirpation rate and
assign it a move. The prior distribution of extirpation rates is given
log_sd and log_mean values that give the
prior expected value of one – i.e. the mean rate of area gain and area
loss are equal under the prior.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log_sd &lt;- 0.5
log_mean &lt;- ln(1) - 0.5*log_sd^2
extirpation_rate ~ dnLognormal(mean=log_mean, sd=log_sd)
moves[2] = mvScale(extirpation_rate, weight=2)
</code></pre></div></div>

<p>then create a matrix of extirpation rates</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_areas) {
  for (j in 1:n_areas) {
    er[i][j] &lt;- 0.0       
  }
  er[i][i] := extirpation_rate
}
</code></pre></div></div>

<p>Note that er is a diagonal matrix whose diagonal values are
determined (:=) by the stochastic variable,
extirpation_rate. We can now create our relative rate
matrix, Q_DEC, with the fnDECRateMatrix
function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_DEC := fnDECRateMatrix(dispersalRates=dr, extirpationRates=er)
</code></pre></div></div>

<p>Note, fnDECRateMatrix does not rescale its elements in any
way, so transition rates share the same time scale as the underlying
tree. This scaling is in contrast to the standard molecular substitution
processes that are available in RevBayes, such as fnGTR,
whose rates are rescaled such that the process is expected to produce
one event per site per unit time.</p>

<p>Next, we need to create the cladogenetic probability matrix.
Cladogenetic event probabilities are given by a transition probability
matrix, not a rate matrix. First, we will provide the vector to indicate
that we wish to consider only subset sympatry and allopatry events.
Next, we will create a vector of prior weights on cladogenesis events
that fixes all cladogenetic events to be equiprobable.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clado_event_types &lt;- [ "s", "a" ]
clado_event_probs &lt;- simplex(1, 1)
P_DEC := fnDECCladoProbs(eventProbs=clado_event_probs,
                            eventTypes=clado_event_types,
                            numCharacters=n_areas)
</code></pre></div></div>

<p>Finally, all our DEC model components are encapsulated in the
dnPhyloCTMCClado distribution, which is similar to
dnPhyloCTMC except specialized to integrate over
cladogenetic events. Although this dataset has four areas, it is
recognized single character with states valued from 1 to $2^4$, hence
nSites=1.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m_bg ~ dnPhyloCTMCClado(tree=tree,
                           Q=Q_DEC,
                           cladoProbs=P_DEC,
                           branchRates=rate_bg,
                           nSites=1,
                           type="NaturalNumbers")
</code></pre></div></div>

<p>Finally, attach the observed ranges to the model. Be sure to use the
natural number valued range characters, dat_range_n, and
not the presence-absence range characters, dat_range_01.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m_bg.clamp(dat_range_n)
</code></pre></div></div>

<p>Add the monitors.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[1] = mnScreen(rate_bg, extirpation_rate, printgen=100)
monitors[2] = mnModel(file=out_fn+".params.log", printgen=10)
monitors[3] = mnFile(tree, file=out_fn+".tre", printgen=10)
monitors[4] = mnJointConditionalAncestralState(tree=tree,
                                                    ctmc=m_bg,
                                                    filename=out_fn+".states.log",
                                                    type="NaturalNumbers",
                                                    printgen=10,
                                                    withTips=true,
                                                    withStartStates=true)
</code></pre></div></div>

<p>The mnJointConditionalAncestralState monitor samples
ancestral states from the phylogeny, tree, according to the
model of evolution, m_bg, and stores it to the file named
“simple.states.log”. Each row in the states file lists the
joint sample of ancestral states conditioned on the tip values for the
entire tree (i.e. a <em>joint</em> ancestral state sample
<em>conditional</em> on the tip states). Each column corresponds
to the phylogenetic node index for that particular MCMC sample. The
index is used used to match the state samples with the tree samples,
which is especially important when the topology is a random variable
(Section [sec:bg_phylo]).</p>

<p>The remaining tasks should be familiar from previous tutorials, so we
can proceed briskly. Prepare the model graph for analysis by creating a
Model object.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(m_bg)
</code></pre></div></div>

<p>Create the MCMC object from the model, moves, and monitors
variables, and run the MCMC analysis.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, moves, monitors)
mymcmc.run(3000)
</code></pre></div></div>

<h2 id="results-results-unnumbered">Results {#results .unnumbered}</h2>

<p><em>Example results are located at</em></p>

<p>The script located at scripts/make_anc_states.Rev
contains code to construct an ancestral state tree. Like all RevBayes
scripts, this script may be executed from the command line. Because this
is the first time using the script, we’ll enter the code manually. To
use it for future analyses, just modify the out_str
variable to match the prefix of the target analysis, save the file, then
execute the script by typing “rb
scripts/make_anc_states.Rev” into the command line.</p>

<blockquote class="figure">
  <p><img src="figures/fig_simple_FigTree_ase.png" alt="" /> 
Annotated tree with
ancestral state estimates in <code class="highlighter-rouge">FigTree</code>.This tree was
generated by ancestralStateTree in RevBayes.The most
probable end state of each branch (before cladogenesis) is shown at each
node.Branches are labeled with the posterior probability for the
ancestral state on the tipwards end of the branch.</p>
</blockquote>

<p>After opening a new RevBayes session, create helper variables for
files we’ll work with.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>out_str = "output/simple"
out_state_fn = out_str + ".states.log"
out_tree_fn = out_str + ".tre"
out_mcc_fn = out_str + ".mcc.tre" 
</code></pre></div></div>

<p>Build a maximum clade credibility tree from the posterior tree
distribution, discarding the first 25% of samples. (Note, this step is
gratuitous when we assume a fixed phylogeny, but essential when we
estimate the phylogeny in Section [sec:bg_phylo]).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree_trace = readTreeTrace(file=out_tree_fn, treetype="clock")
tree_trace.setBurnin(0.25)
n_burn = tree_trace.getBurnin()
</code></pre></div></div>

<p>Compute and save the maximum clade credibility tree</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mcc_tree = mccTree(tree_trace, file=out_mcc_fn)
</code></pre></div></div>

<p>Get the ancestral state trace from simple.states.log</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>state_trace = readAncestralStateTrace(file=out_state_fn)
</code></pre></div></div>

<p>Get the ancestral state tree trace from simple.tre. It is
important to use readAncestralTreeTrace and not
readTreeTrace to properly annotate the tree with ancestral
states.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree_trace = readAncestralStateTreeTrace(file=out_tree_fn, treetype="clock")
</code></pre></div></div>

<p>Finally, compute and save the ancestral state tree as
simple.ase.tre.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>anc_tree = ancestralStateTree(tree=mcc_tree,
                              ancestral_state_trace_vector=state_trace,
                              tree_trace=tree_trace,
                              include_start_states=true,
                              file=out_str+".ase.tre",
                              burnin=n_burn,
                              site=0)
</code></pre></div></div>

<p>We can review the output from ancestralStateTree in
<code class="highlighter-rouge">FigTree</code>(Figure [fig:simple_FigTree_ase]).</p>

<p>Ancestral state trees are annotated with the first three most probable
ancestral states along with their posterior probabilities. When the tree
is a random variable, as it is in later exercises, additional
information about phylogenetic uncertainty is reported.</p>

<p>Finally, we can also generate a figure with ancestral states that is
suitable for publication using the <code class="highlighter-rouge">R</code>package
RevGadgets (Figure [fig:simple_RevGadgets_ase]). The
script is easily modified for use with different datasets. To create
build a figure, open an <code class="highlighter-rouge">R</code>session and load the plotting
script with the source function</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("plot_anc_state.simple.R")
</code></pre></div></div>

<blockquote class="figure">
  <p><img src="figures/fig_simple_RevGadgets_ase.png" alt="" /> 
Tree with
ancestral state estimates for the “simple” analysis. Nodes are annotated
with ancestral states before and after cladogenetic events. The
ancestral range with the highest posterior probability is shown. Colors
of markers indicate the range state.</p>
</blockquote>

<p>Notice that the model infers a widespread ancestral range for the clade
(KOMH) approximately four million years ago when only Kauai existed.
Similar geologically unrealistic widespread ranges are estimated for the
<em>Agyroxiphium</em> clade (KMH) and the <em>D.
sheriffiana</em> and <em>D. arborea</em> clade (OMH). The
remaining tutorials will focus on improvements to the simple DEC model
presented here.</p>

<h1 id="sec:bg_epoch">An improved DEC analysis</h1>

<p>In this section, we’ll introduce a suite of model features that lend
towards more realistic biogeographic analyses. Topics include applying
range size constraints, stratified (or epoch) models of
paleoconnectivity, function-valued dispersal rates, and incorporating
uncertainty in paleogeographic event time estimates. These modifications
should produce more realistic ancestral range estimates, e.g. that a
volcanic island may only be colonized once it has formed, and that
distance should have some bearing on dispersal rate.</p>

<p>To accomplish this, we’ll incorporate (paleo-)geographical data for the
Hawaiian archipelago, summarized in Table [tab:paleogeo]. Even though
we will continue to use four areas (K, O, M, H) in this section, we will
use all six areas (R, K, O, M, H, Z) in Section [sec:bg_phylo], hence
the full table is given for future reference.</p>

<dl>
  <dt>area             code   $a_{max}$   $a_{min}$   $g_{\bullet R}$   $g_{\bullet K}$   $g_{\bullet O}$   $g_{\bullet M}$   $g_{\bullet H}$   $g_{\bullet Z}$</dt>
  <dt>  ————— —— ———– ———– —————– —————– —————– —————– —————– —————–</dt>
  <dt>  Older islands     R         -           -              -                261               406               500               680              3900</dt>
  <dt>  Kauai             K       5.15        5.05             -                 -                145               239               419              3900</dt>
  <dt>  Oahu              O        3.7         2.2             -                 -                 -                059               239              3900</dt>
  <dt>  Maui Nui          M        1.8         1.3             -                 -                 -                 -                082              3900</dt>
  <dt>  Hawaii            H        0.7         0.3             -                 -                 -                 -                 -               3900</dt>
  <dt>  Mainland          Z         -           -              -                 -                 -                 -                 -                 -</dt>
  <dd>
    <p>Hawaiian paleogeographic data. The six areas are given in Figure
  [fig:hawaii_areas]. Ages $a_{max}$ and $a_{min}$ report the maximum
  and minimum origination times for the given island [adapted from
  @Neall2008]. Distances $g_{ij}$ report the shortest geographical
  distance from the coast of the row’s area to the column’s area
  (measured at present).<span data-label="tab:paleogeo"></span></p>
  </dd>
</dl>

<h2 id="analysis">Analysis</h2>

<p>Start by creating variables for the tree file, the range data, and the
output prefix</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>range_fn = "data/n4/silversword.n4.range.nex"
tree_fn = "data/n4/silversword.tre"
out_fn = "output/epoch"
</code></pre></div></div>

<p>The paleogeographical information from Table [tab:paleogeo] is encoded
in three files named hawaii.n4.times.txt,
hawaii.n4.distances.txt, and
hawaii.n4.connectivity.*.txt.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>geo_fn = "data/n4/hawaii.n4"
times_fn = geo_fn + ".times.txt"
dist_fn = geo_fn + ".distances.txt"
</code></pre></div></div>

<p>Create move index (mvi) and monitor index
(mni) variables to populate the elements of our
moves and monitors vectors, respectively.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvi = 1
mni = 1
</code></pre></div></div>

<p>Read in the presence-absence range characters and record the number of
areas in the dataset</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dat_range_01 = readDiscreteCharacterData(range_fn)
n_areas &lt;- dat_range_01.nchar()
</code></pre></div></div>

<p>Often, biogeographers wish to limit to the maximum allowable range size.
This prohibits widespread species ranges and reduces the total number of
range states in the analysis, thus improving computational efficiency.
We will restrict ranges from including more than two areas. The total
number of ranges equals $\sum_{k=0}^m {n}\choose{k}$ where $n$ is the
total number of areas, $m$ is the maximum number of permissible areas,
and ${n}\choose{k}$ is the number of ways to sample $k$ unordered
areas from a pool of $n$ areas. For $n=4$ and $m=2$, this equals
${4}\choose{0} + {4}\choose{1} + {4}\choose{2} = 1 + 4 + 6 = 11$
states.</p>

<p>First, compute the number of states</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>max_areas &lt;- 2
n_states &lt;- 0
for (k in 0:max_areas) n_states += choose(n_areas, k)
</code></pre></div></div>

<p>then use n_states to format the dataset for the reduced
state space</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dat_range_n = formatDiscreteCharacterData(dat_range_01, "DEC", n_states)
</code></pre></div></div>

<p>Our state space now includes only 11 states ($\emptyset$, K, O, M, H,
KO, KM, OM, KH, OH, MH).</p>

<p>Record the complete list of range descriptions to file</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>state_desc = dat_range_n.getStateDescriptions()
state_desc_str = "state,range\n"
for (i in 1:state_desc.size())
{
    state_desc_str += (i-1) + "," + state_desc[i] + "\n"
}
write(state_desc_str, file=out_fn+".state_labels.txt")
</code></pre></div></div>

<p>As with the previous analysis, we’ll brazenly assume we know the dated
species phylogeny without error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree &lt;- readTrees(tree_fn)[1]
</code></pre></div></div>

<p>Next, we’ll read and structure our paleogeographic data. Read in the
list of minimum and maximum ages of island formation</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time_bounds &lt;- readDataDelimitedFile(file=times_fn, delimiter=" ")
n_epochs &lt;- time_bounds.size()
</code></pre></div></div>

<p>Read in the vector of matrices that describe the connectivity between
areas over time. Note, there is one connectivity matrix per epoch,
ordered from oldest to youngest.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  epoch_fn[i] = geo_fn + ".connectivity." + i + ".txt"
  connectivity[i] &lt;- readDataDelimitedFile(file=epoch_fn[i], delimiter=" ")
}
</code></pre></div></div>

<p>The area connectivity file for the third epoch (when K, O, and M exist,
but not H) contains</p>

<div class="console highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1 1 1 0
    1 1 1 0
    1 1 1 0
    0 0 0 0
</code></pre></div></div>

<p>Dispersal events between, say, K and M will be penalized by distance
rather than be forbidden by non-connectivity.</p>

<p>Read in the matrix of distances between all pairs of areas (km). For
simplicity, we will assume that distances remained constant across
epochs, even though these distances certainly varied over time.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>distances &lt;- readDataDelimitedFile(file=dist_fn, delimiter=" ")
</code></pre></div></div>

<p>The distances files contains</p>

<div class="console highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    001 145 239 419
    145 001 059 239
    239 059 001 082
    419 239 082 001
</code></pre></div></div>

<p>and, if we assume the relative distance between islands remains roughly
constant over time, then one set of distances is suitable for use for
all four epochs.</p>

<p>Next, we’ll build an enhanced DEC model. Like before, we’ll define the
rate matrix in terms of relative rates, then rescale the entire matrix
with the biogeographic rate scaling parameter rate_bg.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log10_rate_bg ~ dnUniform(-4,2)
log10_rate_bg.setValue(-2)
rate_bg := 10^log10_rate_bg
moves[mvi++] = mvSlide(log10_rate_bg, weight=4)
</code></pre></div></div>

<p>Fix the base dispersal rate to 1</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispersal_rate &lt;- 1.0
</code></pre></div></div>

<p>Dispersal rates might make use of some extrinsic information, such as
geographical distances between areas (missing reference). We
model this as $d_{ij} = \exp(-a g_{ij})$ where $g_{ij}$ is the
geographical distance between areas $i$ and $j$ and $a$ is a parameter
that scales distance. Note that all dispersal rates are equal when
$a=0$. Add a distance scale parameter</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>distance_scale ~ dnUnif(0,20)
distance_scale.setValue(0.01)
moves[mvi++] = mvScale(distance_scale, weight=3)
</code></pre></div></div>

<p>Now we can assign rates that are functions of distance between all pairs
of areas, <em>but also over all epochs</em>. To accomplish this,
notice we now have an outer loop over the number of epochs,
n_epochs. This is used to construct a vector of dispersal
matrices, one matrix per epoch. It is crucial to note that all of
elements are assigned the value 0.0 unless the if-statement
“if (connectivity[i][j][k] &gt; 0)”  evaluates to
true. That is, dispersal rates between areas j
and k for epoch i are non-zero if and only if
the connectivity matrix element connectivity[i][j][k]
has a positive value! When this condition is met, the dispersal rate is
determined by the exponential function of inverse distance given above.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  for (j in 1:n_areas) {
    for (k in 1:n_areas) {
      dr[i][j][k] &lt;- 0.0
      if (connectivity[i][j][k] &gt; 0) {
        dr[i][j][k]  := dispersal_rate * exp(-distance_scale * distances[j][k])
      }
    }
  }
}
</code></pre></div></div>

<p>We will assign the same extirpation prior as was done in the simple
analysis in the previous section</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log_sd &lt;- 0.5
log_mean &lt;- ln(1) - 0.5*log_sd^2
extirpation_rate ~ dnLognormal(mean=log_mean, sd=log_sd)
moves[mvi++] = mvScale(extirpation_rate, weight=2)
</code></pre></div></div>

<p>and then provide the appropriate extirpation matrix structure</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  for (j in 1:n_areas) {
    for (k in 1:n_areas) {
      er[i][j][k] &lt;- 0.0
    }
    er[i][j][j] := extirpation_rate
  }
}
</code></pre></div></div>

<p>Now we have a vector of dispersal rates, dr, and an vector
of extirpation rates, er, in stored in the RevBayes
workspace. We’ll use these to create a vector of four DEC rate matrices,
one for each epoch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  Q_DEC[i] := fnDECRateMatrix(dispersalRates=dr[i],
                              extirpationRates=er[i],
                              maxRangeSize=max_areas)
}
</code></pre></div></div>

<p>Next, we need to define breakpoints for when the underlying
paleogeographic state/connectivity changes. In our case, we’ll define
the epoch breakpoints as uniformly distributed random variables that are
bounded by the minimum and maximum age estimates for when each new
island complex formed (Table [tab:paleogeo]). This is easily done
using a for loop over the number of epochs. Note, we define the end of
the final epoch as the present.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  time_max[i] &lt;- time_bounds[i][1]
  time_min[i] &lt;- time_bounds[i][2]
  if (i != n_epochs) {
      epoch_times[i] ~ dnUniform(time_min[i], time_max[i])
      moves[mvi++] = mvSlide(epoch_times[i], delta=(time_max[i]-time_min[i])/2)
  } else {
      epoch_times[i] &lt;- 0.0
  }
}
</code></pre></div></div>

<p>Now that we have variables for the timing (epoch_times)
and character (Q_DEC via connectivity) of
paleogeographic change throughout the Hawaiian archipelago, we’re ready
to unify these objects with the fnEpoch function. This
function requires a vector of rate matrices, a vector of epoch end
times, and a vector of rate multipliers as arguments. Internally, the
function computes the appropriate probabilities for state transitions
along branches according under a piecewise constant continuous-time
Markov chain. The important consequence of using an epoch model is that
transition probabilities for anagenetic events depend on the geological
age of the branch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_DEC_epoch := fnEpoch(Q=Q_DEC, times=epoch_times, rates=rep(1,n_epochs))
</code></pre></div></div>

<p>Here, we treat the probability of different types of cladogenetic events
as a random variables to be estimated.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clado_event_types &lt;- [ "s", "a" ]
p_sympatry ~ dnUniform(0,1)
p_allopatry := abs(1.0 - p_sympatry)
clado_type_probs := simplex(p_sympatry, p_allopatry)
moves[mvi++] = mvSlide(p_sympatry, weight=2)
P_DEC := fnDECCladoProbs(eventProbs=clado_type_probs,
                         eventTypes=clado_event_types,
                         numCharacters=n_areas,
                         maxRangeSize=max_areas)
</code></pre></div></div>

<p>For this dataset, we assume cladogenetic probabilities are constant with
respect to geological time. Using time-dependent cladogenetic
probabilities (fnEpochCladoProbs) and mixtures of
cladogenetic probabilities (fnMixtureCladoProbs) will be
covered in future tutorials.</p>

<p>Among the four areas, only Kauai existed at the provided origination
time of the clade, so will set it as the only valid starting state
through the root frequency distribution.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rf_DEC &lt;- rep(0, n_states)
rf_DEC[2] &lt;- 1 
rf_DEC &lt;- simplex(rf_DEC)
</code></pre></div></div>

<p>We have created all the necessary model variables. Now we can create the
phylogenetic model of anagenetic and cladogenetic character evolution.
dnPhyloCTMCClado will internally make use of the
time-heterogeneous probabilities embedded in the epoch rate generator,
Q_DEC_epoch.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m_bg ~ dnPhyloCTMCClado(tree=tree,
                        Q=Q_DEC_epoch,
                        cladoProbs=P_DEC,
                        branchRates=rate_bg,
                        rootFrequencies=rf_DEC,
                        type="NaturalNumbers",
                        nSites=1)
</code></pre></div></div>

<p>Attach the observed range data to the distribution</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m_bg.clamp(dat_range_n)
</code></pre></div></div>

<p>And the rest we’ve done before…</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[mni++] = mnScreen(printgen=100, rate_bg, extirpation_rate, distance_scale)
monitors[mni++] = mnModel(file=out_fn+".model.log", printgen=10)
monitors[mni++] = mnFile(tree, filename=out_fn+".tre", printgen=10)
monitors[mni++] = mnJointConditionalAncestralState(tree=tree,
                                                       ctmc=m_bg,
                                                       type="NaturalNumbers",
                                                       withTips=true,
                                                       withStartStates=true,
                                                       filename=out_fn+".states.log",
                                                       printgen=10)
</code></pre></div></div>

<p>Wrap the model graph into a model object</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(m_bg)
</code></pre></div></div>

<p>then build and run MCMC</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, moves, monitors)
mymcmc.run(5000)
</code></pre></div></div>

<h2 id="results">Results</h2>

<p><em>Example results are located at
output_example/epoch.*</em></p>

<p>When compared to the ancestral state estimates from the “simple”
analysis (Figure [fig:simple_RevGadgets_ase]), these results are far
more consonant with what we understand about the origination times of
the islands (Table [tab:paleogeo]). First, this reconstruction asserts
that the clade originated in the modern Hawaiian islands at a time when
only Kauai was above sea level. Similarly, the <em>D.
sheriffiana</em> and <em>D. arborea</em> clade no longer
estimates OMH as its ancestral range, since Maui and Hawaii had not yet
formed 2.4 Ma. The ancestral range for the <em>Agyroxiphium</em>
clade is Maui (M) with probability 0.41 and Maui+Hawaii (MH) with
probability 0.33, whereas previously it gave high support to the range
KMH.</p>

<p>It may be that these are relatively accurate historical biogeographic
estimates, or they may contain artifacts as a result of assuming a fixed
and errorless phylogeny. The next tutorials discuss how to jointly
estimate phylogeny and biogeography, which potentially improves the
estimation of divergence times, tree topology, and ancestral ranges.</p>

<blockquote class="figure">
  <p><img src="figures/fig_epoch_RevGadgets_ase.png" alt="" /> 
Tree with ancestral
state estimates. Nodes are annotated with ancestral states before and
after cladogenetic events. Most probable states are shown. Colors of
markers indicate the range state. Sizes of markers indicate the
posterior probability of that state.</p>
</blockquote>

<h1 id="sec:bg_phylo">Biogeographic dating using DEC</h1>

<p>This analysis will jointly estimate phylogeny and biogeography. One
benefit is that the biogeographic analysis will intrinsically
accommodate phylogenetic uncertainty, both in terms of topology and
branch lengths. Another is that paleogeographic evidence has the
potential provide information about the geological timing of speciation
events in the phylogeny <a href="#Ho2015">(Ho et al. 2015)</a>. Finally, biogeographic data may lend
support to certain phylogenetic relationships that have poor resolution
otherwise.</p>

<p>As mentioned in Section [sec:bg_simple], Hawaiian silverswords are
nested within the subtribe <em>Madiinae</em>, alongside the
tarweeds, a clade of plants inhabiting in western North America. Fossil
pollen evidence indicates that <em>Madiinae</em> diversified
during a period of aridification from 15–5 Ma in the western regions of
North America <a href="#Baldwin1991">(Baldwin et al. 1991)</a>. It’s clear that silverswords colonized
Hawaii from western North America, but the timing of the event is
difficult to estimate. Even though the oldest Hawaiian island they
inhabit is Kauai, it is possible that silverswords first colonized older
islands in the Emperor Island chain that predate the formation of Kauai
(ca 5.1 Ma).</p>

<p>This makes the application of standard node-based biogeographic
calibrations challenging, because it would require a strong assumption
about when and how many times the oldest silversword lineages colonized
Kauai. Did silverswords colonize Kauai once directly from the California
coast? Or did the colonize the younger islands multiple times from older
islands in the chain? And did the event occur immediately after Kauai
surfaced or much later? Because we cannot observe the timing and nature
of this event directly, we will integrate over all possible evolutionary
histories using process-based biogeographic dating method described in
@Landis2016.</p>

<blockquote class="figure">
  <p><img src="figures/fig_biogeo_dating.png" alt="" /> 
Cartoon of biogeographic
transition probabilities as functions of geological time, and how that
relates to speciation times. (a) Areas split, dispersal before split,
positive probability; (b) Areas split, dispersal after split, zero
probability; (c) Areas merge, dispersal after merge, positive
probability; (d) Areas merge, dispersal before merge, zero probabilty.
Original figure and details regarding cartoon assumptions are found in
@Landis2016.</p>
</blockquote>

<p>The basic idea is that an empirically informed epoch model is capable of
creating conditions that favor key evolutionary transitions to occur
during one time interval over another. Unlike the time-homogeneous
probabilities that arise from, say, a molecular substitution process,
these age-dependent transition probabilities may identify rate from
time, and thus generate information about branch lengths in units of
absolute time (Figure [fig:biogeo_dating_cartoon]). A biogeographic
process that is constrained by paleogeographic connectivity is
well-suited to this purpose.</p>

<p>Note: like all dating methods, including node calibration methods, tip
dating methods, and fossilized birth death dating methods, process-based
biogeographic dating estimates are prior sensitive and dataset
dependent. Applying this model to alternative data sets should be done
with care!</p>

<p>Much of this tutorial will be similar to the previous sections, except
we are adding a birth-death process and a molecular substitution process
to the model graph.</p>

<h2 id="analysis-1">Analysis</h2>

<p>To use date the silversword radiation using biogeography, it is
necessary that we transition from our simpler 4-area model to a richer
6-area model (see Figure [fig:hawaii_areas]). The mainland area (Z)
is necessary to force the silversword and tarweed clade to originate
apart from the islands. The area corresponding to the older island chain
(R) is necessary because we do not know <em>a priori</em> whether
silverswords colonized the modern islands directly from the mainland (Z
$\rightarrow$ K), or first colonized R and only later dispersed into the
younger islands any number of times (Z $\rightarrow$ R $\rightarrow$ K).
Thus, adding these two areas allows the silversword origin time to
precede the formation of Kauai when the dispersal rate is large.</p>

<p>Additionally, we will add three tarweed taxa to our dataset, increasing
the total number of taxa to 38. We’ll use a molecular alignment for the
internal transcribed spacer (ITS) to estimate the phylogeny, which is a
657bp non-coding locus that is historically important for plant
systematics. Because the locus is relatively short, it will also leave
us with a fair amount of phylogenetic uncertainty in branch length and
topology estimates. However, because we’re estimating phylogeny and
biogeography, it will be correctly incorporated into our ancestral range
estimates.</p>

<p>As usual, we’ll begin by creating variables to manage our input and
output files</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>range_fn = "data/n6/silversword.n6.range.nex"
mol_fn = "data/n6/silversword.mol.nex"
tree_fn = "data/n6/silversword.tre"
out_fn = "output/test_epoch_phy"
geo_fn = "data/n6/hawaii.n6"
times_fn = geo_fn + ".times.txt"
dist_fn = geo_fn + ".distances.txt"
</code></pre></div></div>

<p>Add the analysis helper variables</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvi = 1
mni = 1
n_gen = 1e5    # more parameters, longer run!
</code></pre></div></div>

<p>Read in the molecular alignment</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dat_mol = readDiscreteCharacterData(mol_fn)
</code></pre></div></div>

<p>Read in the species ranges for six areas</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dat_range_01 = readDiscreteCharacterData(range_fn)
</code></pre></div></div>

<p>Compute the number of ranges when ranges may only be one or two areas in
size</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_areas &lt;- dat_range_01.nchar()
max_areas &lt;- 2
n_states &lt;- 0
for (k in 0:max_areas) n_states += choose(n_areas, k)
</code></pre></div></div>

<p>Then format the dataset for the reduced state space</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dat_range_n = formatDiscreteCharacterData(dat_range_01, "DEC", n_states)
</code></pre></div></div>

<p>Record the complete list of range descriptions to file</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>state_desc = dat_range_n.getStateDescriptions()
state_desc_str = "state,range\n"
for (i in 1:state_desc.size())
{
    state_desc_str += (i-1) + "," + state_desc[i] + "\n"
}
write(state_desc_str, file=out_fn+".state_labels.txt")
</code></pre></div></div>

<p>Read the minimum and maximum ages of the island complexes</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time_bounds &lt;- readDataDelimitedFile(file=times_fn, delimiter=" ")
n_epochs &lt;- time_bounds.size()
</code></pre></div></div>

<p>Read in the connectivity matrices between the six areas</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  epoch_fn[i] = geo_fn + ".connectivity." + i + ".txt"
  connectivity[i] &lt;- readDataDelimitedFile(file=epoch_fn[i], delimiter=" ")
}
</code></pre></div></div>

<p>Read the geographical distances between areas</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>distances &lt;- readDataDelimitedFile(file=dist_fn, delimiter=" ")
</code></pre></div></div>

<p>Remember that we are estimating the phylogeny as part of this analysis.
In general, it is possible that certain combinations of phylogeny,
biogeography, and paleogeography have zero-valued likelihoods should the
epoch model introduce reducible rate matrix structures [see the
supplemental of @Buerki2011]. The initial MCMC state, however, must have
a non-zero probability for it to work properly. Although it may not be
needed, we will provide tree_init as a starting tree for
the tree variable that we will create to be safe.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree_init = readTrees(tree_fn)[1]
</code></pre></div></div>

<p>We will record some basic information about the taxon set, the number of
taxa, and the number of branches in the tree</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taxa = tree_init.taxa()
n_taxa = taxa.size()
n_branches = 2 * n_taxa - 2
</code></pre></div></div>

<h3 id="the-tree-model">The tree model</h3>

<p>Because we will estimate the topology and branch lengths parameters, the
tree variable must be declared as a stochastic node with a
prior distribution. For this, we’ll use a constant rate birth-death
process.</p>

<p>Assign root age with a maximum age of 15Ma to reflect the fossil pollen
record for Californian tarweeds <a href="#Baldwin1998">(Baldwin and Sanderson 1998)</a>. No assumption is made
about the minimum root age.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root_age ~ dnUniform(0, 15)
moves[mvi++] = mvScale(root_age, weight=2)
</code></pre></div></div>

<p>Assign the proportion of sampled taxa (we have a non-uniform sampling
scheme, but this should suffice).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rho &lt;- 35/50
</code></pre></div></div>

<p>Assign the birth and death priors. It is important to note that the
birth and death priors induce a root age distribution through the
birth-death process. These priors generate a relatively uniform root age
distribution between 2.5–15 Ma in the absence of data (i.e. running MCMC
with the underPrior=true option).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>birth ~ dnExp(1)
moves[mvi++] = mvScale(birth)
death ~ dnExp(1)
moves[mvi++] = mvScale(death)
</code></pre></div></div>

<p>Instantiate a tree variable generated by a birth-death process</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree ~ dnBDP(lambda=birth, mu=death, rho=rho, rootAge=root_age, taxa=taxa)
</code></pre></div></div>

<p>Add topology and branch length moves</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves[mvi++] = mvNNI(tree, weight=n_branches/2)
moves[mvi++] = mvFNPR(tree, weight=n_branches/8)
moves[mvi++] = mvNodeTimeSlideUniform(tree, weight=n_branches/2)
</code></pre></div></div>

<p>Provide a starting tree to ensure the biogeographic model has non-zero
likelihood</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tree.setValue(tree_init)
root_age.setValue(tree_init.rootAge())
</code></pre></div></div>

<h3 id="the-molecular-model">The molecular model</h3>

<p>To inform our branch lengths (in relative time units) and our topology,
we will specify a simple HKY+$\Gamma4$+UCLN model of molecular
substitution (missing reference).</p>

<p>First specify a base rate for the molecular clock. This prior is uniform
over orders of magnitude, between $10^{-6}$ and $10^3$, and was chosen
to minimize its influence on the tree height.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log10_rate_mol ~ dnUniform(-6, 3)
log10_rate_mol.setValue(-1)
moves[mvi++] = mvSlide(log10_rate_mol, weight=5, delta=0.2)
rate_mol := 10^log10_rate_mol
</code></pre></div></div>

<p>Assign log-normal relaxed clock rate multipliers to each branch in the
tree. These priors have a mean of 1 so each branch prefers a strict
clock model in the absence of data.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>branch_sd &lt;- 1.0
branch_mean &lt;- 0.0 - 0.5 * branch_sd^2
for (i in 1:n_branches) {
    branch_rate_multiplier[i] ~ dnLognormal(mean=branch_mean, sd=branch_sd)
    moves[mvi++] = mvScale(branch_rate_multiplier[i])
    branch_rates[i] := rate_mol * branch_rate_multiplier[i]
}
</code></pre></div></div>

<p>Now we’ll create an HKY rate matrix. First, we create a
Gamma-distributed transition-transversion (Ts/Tv) rate ratio with prior
with mean equal to one</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kappa ~ dnGamma(2,2)
moves[mvi++] = mvScale(kappa)
</code></pre></div></div>

<p>then create a flat Dirichlet prior on the base frequencies over A, C, G,
and T</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bf ~ dnDirichlet([1,1,1,1])
moves[mvi++] = mvSimplexElementScale(bf, alpha=10, weight=2)
</code></pre></div></div>

<p>and, finally, combine the base frequencies and Ts/Tv rate ratio to build
the rate matrix</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_mol := fnHKY(kappa, bf)
</code></pre></div></div>

<p>Next, we’ll create a $+\Gamma4$ across-site rate variation model. First,
we need a parameter to control the amount of site rate variation</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alpha ~ dnUniform(0,50)
moves[mvi++] = mvScale(alpha)
</code></pre></div></div>

<p>and a discretized Gamma distribution with four categories</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>site_rates := fnDiscretizeGamma(alpha, alpha, 4)
</code></pre></div></div>

<p>The distribution of site rates categories has mean equal to one and
variance equal to $1/\alpha$. When alpha grows small, the
amount of site rate heterogeneity increases. When alpha is
large, the variance shrinks to zero, and the site rate multipliers of
site_rates converge to the value 1.</p>

<p>Finally, we’ll create our molecular model of substitution</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m_mol ~ dnPhyloCTMC(Q=Q_mol, tree=tree, branchRates=branch_rates, siteRates=site_rates, type="DNA", nSites=dat_mol.nchar())
</code></pre></div></div>

<p>and attach the ITS alignment</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m_mol.clamp(dat_mol)
</code></pre></div></div>

<h3 id="the-biogeographic-model">The biogeographic model</h3>

<p>The biogeographic model is identical to that described in Section
[sec:bg_epoch], so redundant details are omitted here.</p>

<p>First, create the biogeographic rate parameter.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log10_rate_bg ~ dnUniform(-4,2)
log10_rate_bg.setValue(-2)
rate_bg := 10^log10_rate_bg
moves[mvi++] = mvSlide(log10_rate_bg, weight=4)
</code></pre></div></div>

<p>The relative dispersal rate is fixed to 1</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dispersal_rate &lt;- 1.0
</code></pre></div></div>

<p>the distance scale parameter</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>distance_scale ~ dnUnif(0,20)
distance_scale.setValue(0.001)
moves[mvi++] = mvScale(distance_scale, weight=3)
</code></pre></div></div>

<p>Next, create dispersal rates that are functions of distance between all
pairs of areas, but between areas that exist during epoch
i!</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  for (j in 1:n_areas) {
    for (k in 1:n_areas) {
     dr[i][j][k] &lt;- 0.0
     if (connectivity[i][j][k] &gt; 0) {
       dr[i][j][k] := dispersal_rate * exp(-distance_scale * distances[j][k])
     }
    }
  }
}
</code></pre></div></div>

<p>Create the extirpation rates</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log_sd &lt;- 0.5
log_mean &lt;- ln(1) - 0.5*log_sd^2
extirpation_rate ~ dnLognormal(mean=log_mean, sd=log_sd)
moves[mvi++] = mvScale(extirpation_rate, weight=2)

for (i in 1:n_epochs) {
  for (j in 1:n_areas) {
    for (k in 1:n_areas) {
      er[i][j][k] &lt;- 0.0
    }
    er[i][j][j] := extirpation_rate
  }
}
</code></pre></div></div>

<p>Build a rate matrix for each time interval</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  Q_DEC[i] := fnDECRateMatrix(dispersalRates=dr[i],
                          extirpationRates=er[i],
                          maxRangeSize=max_areas)
}
</code></pre></div></div>

<p>Treat epoch times as random variables, except the present is always the
present (or is it?).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  time_max[i] &lt;- time_bounds[i][1]
  time_min[i] &lt;- time_bounds[i][2]
  if (i != n_epochs) {
    epoch_times[i] ~ dnUniform(time_min[i], time_max[i])
    moves[mvi++] = mvSlide(epoch_times[i], delta=(time_bounds[i][1]-time_bounds[i][2])/2)
  } else {
    epoch_times[i] &lt;- 0.0
  }
}
</code></pre></div></div>

<p>Wrap the vector of rate matrices with the fnEpoch rate
generator function</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q_DEC_epoch := fnEpoch(Q=Q_DEC, times=epoch_times, rates=rep(1, n_epochs))
</code></pre></div></div>

<p>Here, we treat the probability of different types of cladogenetic events
as a random variable to be estimate.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clado_event_types &lt;- [ "s", "a" ]
p_sympatry ~ dnUniform(0,1)
p_allopatry := abs(1.0 - p_sympatry)
moves[mvi++] = mvSlide(p_sympatry, delta=0.1, weight=2)
clado_event_probs := simplex(p_sympatry, p_allopatry)
P_DEC := fnDECCladoProbs(eventProbs=clado_event_probs,
                         eventTypes=clado_event_types,
                         numCharacters=n_areas,
                         maxRangeSize=max_areas)
</code></pre></div></div>

<p>Based on fossil pollen evidence, force range state and the root of the
tree to be the mainland area (Z)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rf_DEC &lt;- rep(0, n_states)
rf_DEC[n_areas+1] &lt;- 1  # Mainland (Z) is the only possible starting state
rf_DEC &lt;- simplex(rf_DEC)
</code></pre></div></div>

<p>Create the phylogenetic model of range evolution</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m_bg ~ dnPhyloCTMCClado(tree=tree,
                           Q=Q_DEC_epoch,
                           cladoProbs=P_DEC,
                           branchRates=rate_bg,
                           rootFrequencies=rf_DEC,
                           type="NaturalNumbers",
                           nSites=1)        
</code></pre></div></div>

<p>Attach the species range dataset to the model</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m_bg.clamp(dat_range_n)
</code></pre></div></div>

<p>To easily identify interactions between the posterior estimates of
island ages and divergence times, we’ll create a deterministic node to
monitor the age of the silversword radiation. First, create a
deterministic node to monitor the crown age of the silversword radiation</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ingroup_clade &lt;- clade("Wilkesia_hobdyi",
                       "Dubautia_reticulata",
                       "Dubautia_microcephala",
                       "Argyroxiphium_caliginis")

ingroup_age := tmrca(tree, ingroup_clade)
</code></pre></div></div>

<p>Next, create a vector of variables to report the posterior probability
that the clade originates <em>before</em> a given island. When the
first argument in of the ifelse function returns
true, the node has value 1 and 0
otherwise. Thus, the mean of this variable gives the posterior
probability that the inequality is satisfied.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_epochs) {
  ingroup_older_island[i] := ifelse(ingroup_age &gt; epoch_times[i], 1, 0)
}
</code></pre></div></div>

<p>Create the standard monitors. One difference is that the
mnFile monitor will now record the posterior distribution
for the tree variable, whereas the previous two tutorials
assumed tree was fixed.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors[mni++] = mnScreen(printgen=100, ingroup_age)
monitors[mni++] = mnModel(file=out_fn+".model.log", printgen=100)
monitors[mni++] = mnFile(tree, filename=out_fn+".tre", printgen=100)
monitors[mni++] = mnJointConditionalAncestralState(tree=tree,
                                                       ctmc=m_bg,
                                                       type="NaturalNumbers",
                                                       withTips=true,
                                                       withStartStates=true,
                                                       filename=out_fn+".states.log",
                                                       printgen=100)
</code></pre></div></div>

<p>Because ingroup_older_island does not contribute to the
model likelihood, it must be manually introduced to the model object.
Compose the model object.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(m_bg, ingroup_older_island)
</code></pre></div></div>

<p>Create the MCMC object and run the analysis.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, moves, monitors)
mymcmc.run(n_gen)
</code></pre></div></div>

<blockquote class="figure">
  <p><img src="figures/fig_simple_phy_RevGadgets_ase.png" alt="" /> 
Joint estimate of phylogeny and biogeography, ignoring paleogeography.</p>
</blockquote>

<h2 id="results-1">Results</h2>

<p><em>Example results are located at and</em></p>

<p>To understand the influence of the epoch model on ancestral range and
divergence time estimation, it is important to run addition analyses
with alternative settings. Scripts to jointly estimate molecular
evolution, historical biogeographic, and phylogenetic parameters are
available as scripts/run_simple_phy.Rev and
scripts/run_epoch_phy.Rev. The “epoch” analysis is
identical to the analysis just described. The “simple” analysis is
similar to the “epoch” analysis, except it substitutes the
paleogeography-aware model of range evolution (see Section
[sec:bg_epoch]) for a paleogeography-naive model (see Section
[sec:bg_simple]).</p>

<blockquote class="figure">
  <p><img src="figures/fig_epoch_phy_RevGadgets_ase.png" alt="" /> 
Joint estimate of phylogeny and biogeography, conditioning on paleogeography through the epoch model.</p>
</blockquote>

<p>We see that simple analysis (Figure [fig:simple_phy]) estimates the
ancestral range at the root of the clade as Maui+Mainland (MZ). This is
unrealistic, both because of the extreme distance between those areas,
but also the simple analysis estimates the root age to be 10.3 (HPD95%
4.6, 15.0) Ma, well before Maui originated. (Date estimates are reported
in the simple_phy.mcc.tre and
simple_phy.model.log files.) The simple model also infers
Kauai+Maui (KM) as the ancestral range of living silverswords and a
crown age of 7.2 (HPD95% 2.5, 13.5) Ma, which is impossibly ancient
given the islands’ ages.</p>

<p>The epoch analysis (Figure [fig:epoch_phy]) produces more sensible
ancestral range estimates, with Kauai being colonized first, and younger
islands only being colonized as they become available. The crown age of
silverswords is estimated as 2.5 (HPD95% 0.7, 4.3) Ma. When comparing
the results to the earlier fixed-phylogeny epoch results in Figure
[fig:epoch_RevGadgets_ase], we recover a greater role for
cladogenesis for the younger speciation events. These two analyses only
differ in terms of whether the phylogeny is fixed or estimated, so it is
likely a result of phylogenetic error in the fixed tree.</p>

<blockquote class="figure">
  <p><img src="figures/fig_simple_ages.png" alt="" /> 
Plot of posterior samples for island ages and the origin time of living silverswords.The colors black,
blue, red, orange, and green correspond to the origination times of
Kaui, Oahu, Maui, Hawaii, and the silversword clade, respectively.The
left panel ignores paleogeography, allowing silverswords to originate
well before the formation of Kauai (epoch_times[1]).The
right panel conditions of paleogeography, which prefers a silversword
crown age that follows the formation of Kauai.</p>
</blockquote>

<blockquote>
  <p><img src="figures/fig_epoch_ages.png" alt="" />
Plot of posterior samples for island ages and the origin time of
living silverswords. The colors black, blue, red, orange, and green
correspond to the origination times of Kaui, Oahu, Maui, Hawaii, and the
silversword clade, respectively. The left panel ignores paleogeography,
allowing silverswords to originate well before the formation of Kauai
(epoch_times[1]). The right panel conditions of
paleogeography, which prefers a silversword crown age that follows the
formation of Kauai.</p>
</blockquote>

<p>In Tracer, one can look at the sampled posterior of island ages in
comparison the origination time of crown silverswords (Figure
[fig:epoch_ages]). The left panel shows the simple analysis, where
crown silverswords often originate before the formation of Kauai. The
right panel shows that crown silverswords probably originated before the
formation of Maui, but after the formation of Kauai.</p>

<dl>
  <dt>Model    $P(a_s&gt;a_K)$   $P(a_s&gt;a_O)$   $P(a_s&gt;a_M)$   $P(a_s&gt;a_H)$</dt>
  <dt>  ——– ————– ————– ————– ————–</dt>
  <dt>   simple       0.72           0.94           0.99           1.00</dt>
  <dt>   epoch        0.02           0.26           0.84           0.99</dt>
  <dd>
    <p>Posterior probability that the age of crown silverswords ($a_s$) is
  older than the origination times of K, O, M, and H
  ($a_K, a_O, a_M, a_H$, respectively). The “simple” model (Left)
  ignores paleogeography while the “epoch” model (Right) conditions on
  it.<span data-label="tab:epoch_ages"></span></p>
  </dd>
</dl>

<p>By tabulating the results of the deterministic variable
ingroup_older_island, we measure the posterior
probability that crown silverswords originated before or after each
particular epoch in the model (Table [tab:epoch_ages]). Treating
$P=0.95$ as significant support for an evolutionary outcome, the epoch
model produces strong support that crown silverswords originated after
the formation of Kauai, $P(a_s &gt; a_K) = 0.02 &lt; 1-0.95$ and weak support
that they originated after the formation of Oahu,
$P(a_s &gt; a_O) = 0.26 &gt; 1-0.95$.</p>

<p>Version dated:</p>


      <ol class="bibliography"><li><span id="Ree2005">Ree R.H., Moore B.R., Webb C.O., Donoghue M.J., Crandall K. 2005. A likelihood framework for inferring the evolution of geographic range on phylogenetic trees. Evolution. 59:2299–2311.</span>

<a href="https://doi.org/10.1111/j.0014-3820.2005.tb00940.x">10.1111/j.0014-3820.2005.tb00940.x</a>

</li>
<li><span id="Landis2013a">Landis M.J., Matzke N.J., Moore B.R., Huelsenbeck J.P. 2013. Bayesian Analysis of Biogeography when the Number of Areas is Large. Systematic Biology. 62:789–804.</span>

</li>
<li><span id="Baldwin1991">Baldwin B.G., Kyhos D.W., Dvorak J., Carr G.D. 1991. Chloroplast DNA evidence for a North American origin of the Hawaiian silversword alliance (Asteraceae). Proceedings of the National Academy of Sciences. 88:1840–1843.</span>

<a href="https://doi.org/10.1073/pnas.88.5.1840">10.1073/pnas.88.5.1840</a>

</li>
<li><span id="Baldwin1998">Baldwin B.G., Sanderson M.J. 1998. Age and rate of diversification of the Hawaiian silversword alliance (Compositae). Proceedings of the National Academy of Sciences. 95:9402–9406.</span>

<a href="https://doi.org/10.1073/pnas.95.16.9402">10.1073/pnas.95.16.9402</a>

</li>
<li><span id="Ho2015">Ho S.Y.W., Tong K.J., Foster C.S.P., Ritchie A.M., Lo N., Crisp M.D. 2015. Biogeographic calibrations for the molecular clock. Biology Letters. 11:20150194.</span>

<a href="https://doi.org/10.1098/rsbl.2015.0194">10.1098/rsbl.2015.0194</a>

</li></ol>

<script type="text/javascript">
var _ol = document.querySelectorAll('ol');
for (var i = 0, elem_ol; elem_ol = _ol[i]; i++) {
	if ( elem_ol.classList == "bibliography" ) {
		var _li = elem_ol.getElementsByTagName("li");
		//for (var j = 0, elem_li; elem_li = _li[j]; j++)
		//{
		//	elem_li.innerHTML = elem_li.innerHTML.replace(/(https?:\/\/)([^\s<]+)/,"<a href=\"$1$2\">$2");
		//}
		if(_li.length > 0)
			elem_ol.outerHTML = "<h2>References</h2>"+elem_ol.outerHTML
	}
}
</script>
      <br>
<footer>
  <div class="container">
  <div class="row">
    <div class="col-sm-12" align="center">
      <a href="https://github.com/revbayes">GitHub</a> | <a href="/revbayes-site/license">License</a> | <a href="/revbayes-site/citation">Cite RevBayes</a> | <a href="https://groups.google.com/forum/#!forum/revbayes-users">Users' Forum</a>
    </div>
  </div>
  </div>
</footer>

    </div>
    <script src="/revbayes-site/assets/js/vendor/jquery.min.js"></script>
<script src="/revbayes-site/assets/js/vendor/FileSaver.min.js"></script>
<script src="/revbayes-site/assets/js/vendor/jszip.min.js"></script>
<script src="/revbayes-site/assets/js/vendor/bootstrap.min.js"></script>

<script type="text/javascript">
// Add default language
$(":not(code).highlighter-rouge").each(function() {
  
  if( this.classList == "highlighter-rouge") {
    this.classList = "Rev highlighter-rouge";
  }
  
});
// $("code.highlighter-rouge").each(function() {
//   
//   if( this.classList == "highlighter-rouge") {
//       this.classList = "Rev highlighter-rouge";
//   }
//   
// });
</script>

<script src="/revbayes-site/assets/js/base.js"></script>

<script type="text/javascript"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

  </body>
</html>
